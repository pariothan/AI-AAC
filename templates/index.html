<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-AAC</title>
    <script>
        window.APP_CONFIG = {
            basePath: {{ base_path|tojson }}
        };
    </script>
    <style>
        :root {
            --primary: #5465ff;
            --primary-hover: #3f53ec;
            --surface: rgba(255, 255, 255, 0.98);
            --surface-muted: #f2f4ff;
            --surface-strong: #ffffff;
            --border: rgba(84, 101, 255, 0.18);
            --border-strong: rgba(84, 101, 255, 0.32);
            --text-strong: #0f172a;
            --text-muted: #636f88;
            --shadow-lg: 0 28px 60px rgba(15, 23, 42, 0.08);
            --shadow-sm: 0 12px 30px rgba(84, 101, 255, 0.12);
            --radius-lg: 28px;
            --radius-md: 20px;
            --radius-sm: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Arial, sans-serif;
            background: linear-gradient(180deg, #e8efff 0%, #f9fbff 100%);
            color: var(--text-strong);
            height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: stretch;
            padding: 16px;
            overflow: hidden;
        }

        h1, h2, h3 {
            font-weight: 700;
        }

        button {
            font: inherit;
        }

        .app-shell {
            max-width: 1280px;
            width: 100%;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 18px;
            display: flex;
            gap: 20px;
            align-items: stretch;
            min-height: 0;
            height: 100%;
            box-shadow: var(--shadow-lg);
        }

        /* Sidebar - Word Bank */
        .sidebar {
            flex: 0 0 320px;
            background: var(--surface-muted);
            display: flex;
            flex-direction: column;
            gap: 14px;
            border-radius: var(--radius-md);
            padding: 18px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            transition: flex-basis 0.3s ease;
            height: 100%;
            min-height: 0;
            overflow: hidden;
        }

        .sidebar.focused {
            flex-basis: min(520px, 55%);
        }

        .sidebar-header {
            display: flex;
            flex-direction: column;
            gap: 18px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .focus-btn {
            width: 40px;
            height: 40px;
            background: var(--surface-strong);
            border: 1px solid var(--border-strong);
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .focus-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 25px rgba(84, 101, 255, 0.22);
        }

        .focus-btn.active {
            background: var(--primary);
            color: white;
            border-color: transparent;
        }

        .input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .search-box {
            padding-top: 10px;
            border-top: 1px dashed rgba(84, 101, 255, 0.16);
            flex-shrink: 0;
        }

        .search-box input[type="text"] {
            margin-top: 10px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: var(--surface-strong);
            font-size: 15px;
            outline: none;
            transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            color: var(--text-strong);
        }

        input[type="text"]::placeholder {
            color: #9ba5c0;
        }

        input[type="text"]:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(84, 101, 255, 0.18);
            background: #ffffff;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 18px;
            border-radius: var(--radius-sm);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid transparent;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: var(--primary);
            color: #ffffff;
            box-shadow: var(--shadow-sm);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 18px 32px rgba(84, 101, 255, 0.28);
        }

        .word-bank {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }

        .word-bank::-webkit-scrollbar,
        .sentences-list::-webkit-scrollbar {
            width: 10px;
        }

        .word-bank::-webkit-scrollbar-thumb,
        .sentences-list::-webkit-scrollbar-thumb {
            background: rgba(84, 101, 255, 0.2);
            border-radius: 20px;
        }

        .word-bank::-webkit-scrollbar-track,
        .sentences-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .category {
            background: var(--surface-strong);
            border-radius: var(--radius-sm);
            border: 1px solid transparent;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .category:hover {
            border-color: var(--border);
            box-shadow: 0 16px 30px rgba(84, 101, 255, 0.12);
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: var(--text-strong);
            border-radius: var(--radius-sm);
            cursor: pointer;
            user-select: none;
            font-size: 15px;
            font-weight: 600;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .category-header:hover {
            background: rgba(84, 101, 255, 0.08);
        }

        .category-header.expanded {
            background: rgba(84, 101, 255, 0.12);
            color: var(--primary);
        }

        .category-icon {
            font-size: 18px;
            flex-shrink: 0;
            width: 24px;
            text-align: center;
        }

        .category-name {
            flex: 1;
        }

        .category-arrow {
            transition: transform 0.2s ease;
            font-size: 11px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .category-arrow.expanded {
            transform: rotate(90deg);
        }

        .category-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.35s ease;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 0 10px;
        }

        .category-content.expanded {
            max-height: 3000px;
            padding: 10px;
        }

        .bank-term {
            background: var(--surface-muted);
            padding: 9px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 1px solid transparent;
            user-select: none;
            font-size: 15px;
            font-weight: 500;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
            white-space: nowrap;
            box-shadow: 0 8px 18px rgba(84, 101, 255, 0.12);
        }

        .bank-term:hover {
            background: rgba(84, 101, 255, 0.15);
            border-color: rgba(84, 101, 255, 0.35);
            transform: translateY(-2px);
            box-shadow: 0 16px 30px rgba(84, 101, 255, 0.18);
        }

        .bank-term:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .term-count {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px dashed rgba(84, 101, 255, 0.2);
            font-size: 13px;
            color: var(--text-muted);
            text-align: center;
            flex-shrink: 0;
        }

        /* Main Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            gap: 18px;
            align-items: stretch;
            min-height: 0;
        }

        .workspace-suggestions-wrapper {
            flex: 1 1 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            min-width: 0;
            max-width: 100%;
            width: 0;
        }

        .workspace-column {
            flex: 1;
            background: var(--surface-muted);
            border-radius: var(--radius-md);
            padding: 18px 18px 22px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: relative;
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }

        .workspace-heading {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .workspace-heading h2 {
            font-size: 20px;
            letter-spacing: -0.01em;
        }

        .workspace {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-content: flex-start;
            padding: 20px;
            background: var(--surface-strong);
            border-radius: var(--radius-md);
            border: 2px dashed rgba(84, 101, 255, 0.18);
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 1px 4px rgba(84, 101, 255, 0.08);
        }

        .workspace.dragover {
            background: rgba(84, 101, 255, 0.08);
            border-color: rgba(84, 101, 255, 0.38);
            box-shadow: inset 0 0 0 3px rgba(84, 101, 255, 0.18);
        }

        .canvas-term {
            position: relative;
            background: #eef0ff;
            padding: 10px 16px;
            border-radius: 18px;
            box-shadow: 0 12px 20px rgba(84, 101, 255, 0.18);
            cursor: pointer;
            user-select: none;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            border: 1px solid rgba(84, 101, 255, 0.35);
            flex-shrink: 0;
            color: #363dcc;
        }

        .canvas-term:hover {
            transform: translateY(-2px);
            background: #dde1ff;
            box-shadow: 0 18px 28px rgba(84, 101, 255, 0.24);
        }

        .canvas-term:hover::before {
            content: '🔊';
            position: absolute;
            top: -10px;
            left: -10px;
            font-size: 16px;
            background: white;
            border-radius: 50%;
            padding: 4px;
            box-shadow: 0 4px 12px rgba(84, 101, 255, 0.3);
        }

        .canvas-term:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .canvas-term.dragging {
            opacity: 0.55;
        }

        .canvas-term .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff5d72;
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
            box-shadow: 0 10px 18px rgba(255, 93, 114, 0.3);
        }

        .canvas-term:hover .remove-btn {
            display: flex;
        }

        .insertion-marker {
            width: 3px;
            min-height: 50px;
            background: var(--primary);
            border-radius: 3px;
            flex-shrink: 0;
            opacity: 0.7;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
            font-size: 16px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .empty-state-icon {
            font-size: 42px;
        }

        /* Suggestions Panel */
        .suggestions-panel {
            background: var(--surface-muted);
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-radius: var(--radius-md);
            padding: 10px 14px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            min-width: 0;
            overflow: hidden;
        }

        .suggestions-header {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-strong);
            flex-shrink: 0;
            line-height: 1.2;
        }

        .suggestions-list {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 8px;
            min-height: 0;
            padding-bottom: 4px;
            align-items: flex-start;
            width: 100%;
        }

        .suggestions-list::-webkit-scrollbar {
            height: 8px;
        }

        .suggestions-list::-webkit-scrollbar-thumb {
            background: rgba(84, 101, 255, 0.2);
            border-radius: 20px;
        }

        .suggestions-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .suggestion-item {
            padding: 6px 12px;
            background: var(--surface-strong);
            border-radius: var(--radius-sm);
            box-shadow: 0 4px 12px rgba(84, 101, 255, 0.12);
            font-size: 13px;
            color: var(--text-strong);
            border: 1px solid rgba(84, 101, 255, 0.18);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease, opacity 0.2s ease;
            cursor: grab;
            font-weight: 500;
            white-space: nowrap;
            flex-shrink: 0;
            height: fit-content;
            user-select: none;
        }

        .suggestion-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(84, 101, 255, 0.2);
            border-color: rgba(84, 101, 255, 0.35);
            background: #f8f9ff;
        }

        .suggestion-item:active {
            cursor: grabbing;
        }

        .suggestions-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
            padding: 10px 12px;
            background: rgba(84, 101, 255, 0.06);
            border-radius: var(--radius-sm);
            border: 1px dashed rgba(84, 101, 255, 0.2);
            line-height: 1.4;
            white-space: nowrap;
        }

        .suggestions-loading {
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
            padding: 10px 12px;
            font-style: italic;
            white-space: nowrap;
        }

        /* Sentences Panel */
        .sentences-panel {
            flex: 0 0 320px;
            background: var(--surface-muted);
            display: flex;
            flex-direction: column;
            gap: 16px;
            border-radius: var(--radius-md);
            padding: 18px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            transition: flex-basis 0.3s ease;
            height: 100%;
            min-height: 0;
            overflow: hidden;
        }

        .sentences-panel.focused {
            flex-basis: min(520px, 55%);
        }

        .sentences-header-box {
            display: flex;
            flex-direction: column;
            gap: 14px;
            flex-shrink: 0;
        }

        .sentences-header {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sentences-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }

        .sentence-item {
            position: relative;
            padding: 12px 16px;
            background: var(--surface-strong);
            border-radius: var(--radius-sm);
            box-shadow: 0 10px 24px rgba(84, 101, 255, 0.14);
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-strong);
            border: 1px solid rgba(84, 101, 255, 0.22);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
            cursor: pointer;
        }

        .sentence-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 18px 30px rgba(84, 101, 255, 0.22);
            border-color: rgba(84, 101, 255, 0.35);
        }

        .sentence-item:hover::after {
            content: '🔊';
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            font-size: 18px;
            opacity: 0.7;
        }

        .sentences-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            padding: 24px 16px;
            background: rgba(84, 101, 255, 0.08);
            border-radius: var(--radius-sm);
            border: 1px dashed rgba(84, 101, 255, 0.25);
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 250, 255, 0.78);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading.show {
            display: flex;
        }

        .loading-card {
            background: var(--surface);
            border-radius: var(--radius-md);
            padding: 32px 40px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(84, 101, 255, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 18px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-strong);
            font-size: 16px;
            font-weight: 600;
        }

        @media (max-width: 1200px) {
            body {
                height: auto;
                min-height: 100vh;
                overflow-y: auto;
                padding: 12px;
            }

            .app-shell {
                height: auto;
            }

            .container {
                flex-direction: column;
                height: auto;
                padding: 16px;
            }

            .canvas-area {
                flex-direction: column;
                min-height: auto;
            }

            .sidebar,
            .sidebar.focused,
            .sentences-panel,
            .sentences-panel.focused {
                flex: 1 1 auto;
                width: 100%;
                height: auto;
            }

            .workspace-column {
                order: 2;
                height: auto;
            }

            .sentences-panel {
                order: 3;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 8px;
            }

            .container {
                padding: 16px;
            }

            .workspace {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Setup Modal (API Key + Voice) -->
    <div id="setupModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(15, 23, 42, 0.7); display: flex; align-items: center; justify-content: center; z-index: 2000;">
        <div style="background: var(--surface); border-radius: var(--radius-md); padding: 32px; max-width: 500px; width: 90%; max-height: 85vh; overflow-y: auto; border: 1px solid var(--border); box-shadow: var(--shadow-lg);">
            <h2 style="margin-bottom: 16px; font-size: 24px;">Welcome to AI-AAC! 💬</h2>

            <!-- App Description - EDIT THIS SECTION -->
            <div style="background: linear-gradient(135deg, #f0f4ff 0%, #e8edff 100%); border: 1px solid #5465ff; border-radius: var(--radius-sm); padding: 16px; margin-bottom: 20px;">
                <h3 style="font-size: 16px; font-weight: 700; color: var(--text-strong); margin-bottom: 8px;">About This App</h3>
                <p style="font-size: 14px; color: var(--text-strong); line-height: 1.6; margin: 0;">
                    This is a demo of an AI-assisted AAC software designed to be an assistive technology for nonverbal communicators. Currently, AAC softwares provide ~50 words at a time, unchanging by context and are woefully inadequate for communication. There are hundreds of reasons a person may be nonverbal, and almost none of them involve an impairment in language comprehension, or uses that aren't in speech. With this software, context dependant suggestions make picking words easier, and the "generate sentences" button allows you to choose which version of the many nuanced ways that words can be combined you wish to say. There's also a button to send a photo, which will generate ~100 context-relevant vocabulary words that might help where you are! It currently requires an OpenAI key, and OpenAI will charge you for usage. I ended up using about 20 cents worth of credit in about three hours of testing. This can be made far more efficient in the future.
                </p>
            </div>

            <!-- HTTPS Warning -->
            <div id="httpsWarning" style="display: none; background: #fff4e6; border: 1px solid #ff9800; border-radius: var(--radius-sm); padding: 12px; margin-bottom: 16px;">
                <div style="display: flex; gap: 8px; align-items: start;">
                    <span style="font-size: 18px;">⚠️</span>
                    <div style="font-size: 13px; color: #e65100;">
                        <strong>Security Warning:</strong> You're not using HTTPS. Your API key may be visible to attackers. Only use this on trusted networks.
                    </div>
                </div>
            </div>

            <p style="margin-bottom: 16px; color: var(--text-muted); line-height: 1.6; font-size: 14px;">
                To get started, please enter your OpenAI API key and select a voice.
            </p>

            <!-- Security notice -->
            <div style="background: #f0f4ff; border: 1px solid #5465ff; border-radius: var(--radius-sm); padding: 12px; margin-bottom: 16px;">
                <div style="font-size: 13px; color: var(--text-strong); line-height: 1.5;">
                    <strong>🔒 Security Notice:</strong><br>
                    • Your key is stored in your browser only<br>
                    • Never share your API key with others<br>
                    • Monitor your OpenAI usage regularly<br>
                    • This app sends requests through our server
                </div>
            </div>

            <input
                type="password"
                id="apiKeyInput"
                placeholder="sk-..."
                style="width: 100%; padding: 12px 16px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--surface-strong); font-size: 15px; margin-bottom: 12px;"
            />

            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; font-size: 14px; cursor: pointer;">
                <input type="checkbox" id="sessionOnlyCheckbox" style="cursor: pointer;">
                <span>Session only (clear key when browser closes)</span>
            </label>

            <!-- Voice Selection -->
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-size: 14px; font-weight: 600; color: var(--text-strong);">
                    🔊 Select Voice:
                </label>
                <select id="voiceSelectModal" style="width: 100%; padding: 12px 16px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--surface-strong); font-size: 15px; cursor: pointer;">
                    <option value="">Loading voices...</option>
                </select>
                <button id="testVoiceBtn" class="btn" style="margin-top: 8px; width: 100%; background: #f0f4ff; color: var(--primary); border: 1px solid var(--border);">🔊 Test Voice</button>
            </div>

            <div style="display: flex; gap: 12px;">
                <button id="saveSetupBtn" class="btn btn-primary" style="flex: 1;">Save & Continue</button>
            </div>
            <p style="margin-top: 16px; font-size: 13px; color: var(--text-muted);">
                Don't have an API key? <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--primary); text-decoration: underline;">Get one from OpenAI</a>
            </p>
        </div>
    </div>

    <!-- Voice Selection Modal -->
    <div id="voiceModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(15, 23, 42, 0.7); display: none; align-items: center; justify-content: center; z-index: 2000;">
        <div style="background: var(--surface); border-radius: var(--radius-md); padding: 32px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; border: 1px solid var(--border); box-shadow: var(--shadow-lg);">
            <h2 style="margin-bottom: 16px; font-size: 24px;">🔊 Select Voice</h2>
            <p style="margin-bottom: 16px; color: var(--text-muted); font-size: 14px;">
                Choose a voice for text-to-speech. Click "Test" to hear a sample.
            </p>

            <div id="voiceList" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;">
                <!-- Voice items will be populated here -->
            </div>

            <div style="display: flex; gap: 12px;">
                <button id="closeVoiceModalBtn" class="btn" style="flex: 1; background: #f0f4ff; color: var(--primary); border: 1px solid var(--border);">Cancel</button>
            </div>
        </div>
    </div>

    <div class="app-shell">
        <div class="container">
            <!-- Sidebar Word Bank -->
            <div class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <div class="logo">
                        <span>Word Bank</span>
                        <div style="display: flex; gap: 8px;">
                            <input type="file" id="imageInput" accept="image/*" style="display: none;">
                            <button class="focus-btn" id="attachImageBtn" title="Attach Image" style="font-size: 18px;">📷</button>
                            <button class="focus-btn" id="changeApiKeyBtn" title="Change API Key" style="font-size: 14px;">🔑</button>
                            <button class="focus-btn" id="focusWordsBtn">⇄</button>
                        </div>
                    </div>
                    <div class="input-container">
                        <button class="btn btn-primary" id="selectVoiceBtn" style="width: 100%;">🔊 Select Voice</button>
                    </div>
                </div>

                <div class="search-box">
                    <input
                        type="text"
                        id="searchInput"
                        placeholder="Search words"
                    />
                </div>

                <div class="word-bank" id="wordBank"></div>

                <div class="term-count">
                    <span id="termCount">0 words in bank</span>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="workspace-suggestions-wrapper">
                    <div class="workspace-column">
                        <div class="workspace-heading">
                            <h2>Workspace</h2>
                            <button class="btn btn-primary" id="speakAllBtn" style="padding: 8px 16px; font-size: 14px;">🔊 Speak All</button>
                        </div>

                        <div class="workspace" id="workspace">
                            <div class="empty-state">
                                <div class="empty-state-icon">💬</div>
                                <div>Workspace empty</div>
                            </div>
                        </div>
                    </div>

                    <!-- Suggestions Panel -->
                    <div class="suggestions-panel" id="suggestionsPanel">
                        <div class="suggestions-header">
                            <span>💡 Suggested Next</span>
                        </div>
                        <div class="suggestions-list" id="suggestionsList">
                            <div class="suggestions-empty">Add words to workspace to see suggestions</div>
                        </div>
                    </div>
                </div>

                <!-- Sentences Panel -->
                <div class="sentences-panel" id="sentencesPanel">
                    <div class="sentences-header-box">
                        <div class="sentences-header">
                            <span>Sentences</span>
                            <button class="focus-btn" id="focusSentencesBtn">⇄</button>
                        </div>
                        <button class="btn btn-primary" id="generateSentencesBtn">Create Sentences</button>
                    </div>
                    <div class="sentences-list" id="sentencesList">
                        <div class="sentences-empty">No sentences yet.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="loading-card">
            <div class="spinner"></div>
            <div class="loading-text">Generating words...</div>
        </div>
    </div>

    <script>
        const normalizeBasePath = (path) => {
            if (!path || path === '/') {
                return '';
            }
            return path.endsWith('/') ? path.slice(0, -1) : path;
        };

        const BASE_PATH = normalizeBasePath(window.APP_CONFIG?.basePath);
        const buildUrl = (endpoint) => `${BASE_PATH}${endpoint}`;

        // Text-to-Speech functionality
        let selectedVoice = null;
        let availableVoices = [];

        function populateVoiceModal() {
            const voiceList = document.getElementById('voiceList');
            if (!voiceList || availableVoices.length === 0) return;

            // Clear existing items
            voiceList.innerHTML = '';

            // Get saved voice
            const savedVoiceName = localStorage.getItem('tts_voice');

            // Add default option
            const defaultItem = createVoiceItem(null, 'Default Voice', 'System default', savedVoiceName === null || savedVoiceName === '');
            voiceList.appendChild(defaultItem);

            // Add voices, prioritizing English voices
            const englishVoices = availableVoices.filter(v => v.lang.startsWith('en'));
            const otherVoices = availableVoices.filter(v => !v.lang.startsWith('en'));

            if (englishVoices.length > 0) {
                const englishHeader = document.createElement('div');
                englishHeader.style.cssText = 'font-size: 12px; font-weight: 700; color: var(--text-muted); margin-top: 12px; margin-bottom: 4px;';
                englishHeader.textContent = 'English Voices';
                voiceList.appendChild(englishHeader);

                englishVoices.forEach(voice => {
                    const item = createVoiceItem(voice, voice.name, voice.lang, savedVoiceName === voice.name);
                    voiceList.appendChild(item);
                });
            }

            if (otherVoices.length > 0) {
                const otherHeader = document.createElement('div');
                otherHeader.style.cssText = 'font-size: 12px; font-weight: 700; color: var(--text-muted); margin-top: 12px; margin-bottom: 4px;';
                otherHeader.textContent = 'Other Languages';
                voiceList.appendChild(otherHeader);

                otherVoices.forEach(voice => {
                    const item = createVoiceItem(voice, voice.name, voice.lang, savedVoiceName === voice.name);
                    voiceList.appendChild(item);
                });
            }
        }

        function createVoiceItem(voice, name, lang, isSelected) {
            const item = document.createElement('div');
            item.style.cssText = `
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 12px;
                background: ${isSelected ? '#f0f4ff' : 'var(--surface-strong)'};
                border: 1px solid ${isSelected ? 'var(--primary)' : 'var(--border)'};
                border-radius: var(--radius-sm);
                cursor: pointer;
                transition: all 0.2s ease;
            `;

            const info = document.createElement('div');
            info.style.cssText = 'flex: 1;';
            info.innerHTML = `
                <div style="font-weight: 600; font-size: 14px; color: var(--text-strong);">${name}</div>
                <div style="font-size: 12px; color: var(--text-muted);">${lang}</div>
            `;

            const testBtn = document.createElement('button');
            testBtn.className = 'btn';
            testBtn.style.cssText = 'padding: 6px 12px; font-size: 13px; background: #f0f4ff; color: var(--primary); border: 1px solid var(--border);';
            testBtn.textContent = '🔊 Test';
            testBtn.onclick = (e) => {
                e.stopPropagation();
                testVoice(voice);
            };

            const selectBtn = document.createElement('button');
            selectBtn.className = 'btn btn-primary';
            selectBtn.style.cssText = 'padding: 6px 16px; font-size: 13px;';
            selectBtn.textContent = isSelected ? '✓ Selected' : 'Select';
            if (isSelected) {
                selectBtn.style.opacity = '0.7';
            }

            item.appendChild(info);
            item.appendChild(testBtn);
            item.appendChild(selectBtn);

            // Click to select
            item.onclick = () => {
                selectVoice(voice);
                document.getElementById('voiceModal').style.display = 'none';
            };

            return item;
        }

        function testVoice(voice) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance('Hello! This is how I sound.');
            if (voice) {
                utterance.voice = voice;
            }
            utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
        }

        function selectVoice(voice) {
            if (voice) {
                selectedVoice = voice;
                localStorage.setItem('tts_voice', voice.name);
                updateVoiceButtonText(voice.name);
            } else {
                selectedVoice = null;
                localStorage.removeItem('tts_voice');
                updateVoiceButtonText('Default Voice');
            }
        }

        function updateVoiceButtonText(voiceName) {
            const btn = document.getElementById('selectVoiceBtn');
            if (btn) {
                btn.textContent = `🔊 ${voiceName}`;
            }
        }

        function loadVoices() {
            availableVoices = window.speechSynthesis.getVoices();

            // Populate modal dropdown
            const voiceSelectModal = document.getElementById('voiceSelectModal');

            if (availableVoices.length > 0) {
                if (voiceSelectModal) {
                    populateVoiceSelect(voiceSelectModal);
                }

                // Load saved voice preference
                const savedVoice = localStorage.getItem('tts_voice');
                if (savedVoice) {
                    selectedVoice = availableVoices.find(v => v.name === savedVoice);
                    updateVoiceButtonText(savedVoice);
                    if (voiceSelectModal) {
                        voiceSelectModal.value = savedVoice;
                    }
                }
            }
        }

        function populateVoiceSelect(selectElement) {
            if (availableVoices.length === 0) return;

            // Clear existing options
            selectElement.innerHTML = '';

            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '🔊 Default Voice';
            selectElement.appendChild(defaultOption);

            // Add voices
            const englishVoices = availableVoices.filter(v => v.lang.startsWith('en'));
            const otherVoices = availableVoices.filter(v => !v.lang.startsWith('en'));

            if (englishVoices.length > 0) {
                const englishGroup = document.createElement('optgroup');
                englishGroup.label = 'English';
                englishVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    englishGroup.appendChild(option);
                });
                selectElement.appendChild(englishGroup);
            }

            if (otherVoices.length > 0) {
                const otherGroup = document.createElement('optgroup');
                otherGroup.label = 'Other Languages';
                otherVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    otherGroup.appendChild(option);
                });
                selectElement.appendChild(otherGroup);
            }
        }

        // Load voices when they're ready
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }
        loadVoices(); // Call immediately in case voices are already loaded

        function removeAllEmojis(text) {
            // Comprehensive emoji removal - covers all emoji ranges
            return text.replace(/[\u{1F600}-\u{1F64F}]/gu, '') // Emoticons
                       .replace(/[\u{1F300}-\u{1F5FF}]/gu, '') // Misc Symbols and Pictographs
                       .replace(/[\u{1F680}-\u{1F6FF}]/gu, '') // Transport and Map
                       .replace(/[\u{1F1E0}-\u{1F1FF}]/gu, '') // Flags
                       .replace(/[\u{2600}-\u{26FF}]/gu, '')   // Misc symbols
                       .replace(/[\u{2700}-\u{27BF}]/gu, '')   // Dingbats
                       .replace(/[\u{1F900}-\u{1F9FF}]/gu, '') // Supplemental Symbols and Pictographs
                       .replace(/[\u{1FA00}-\u{1FA6F}]/gu, '') // Chess Symbols
                       .replace(/[\u{1FA70}-\u{1FAFF}]/gu, '') // Symbols and Pictographs Extended-A
                       .replace(/[\u{2300}-\u{23FF}]/gu, '')   // Miscellaneous Technical
                       .replace(/[\u{FE00}-\u{FE0F}]/gu, '')   // Variation Selectors
                       .replace(/[\u{200D}]/gu, '')            // Zero Width Joiner
                       .trim();
        }

        function speak(text) {
            // Stop any ongoing speech
            window.speechSynthesis.cancel();

            // Remove emoji from text (keep only the word)
            const cleanText = removeAllEmojis(text);

            if (!cleanText) return;

            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 0.9; // Slightly slower for clarity
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Use selected voice if available
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        function speakAll() {
            // Stop any ongoing speech
            window.speechSynthesis.cancel();

            // Get all words from workspace in order
            const workspace = document.getElementById('workspace');
            const canvasTerms = Array.from(workspace.querySelectorAll('.canvas-term'))
                .map(el => el.textContent.replace('×', '').trim());

            if (canvasTerms.length === 0) {
                alert('No words in workspace to speak!');
                return;
            }

            // Remove emojis from each term and join with spaces
            const cleanTerms = canvasTerms.map(term => removeAllEmojis(term)).filter(term => term);

            const fullText = cleanTerms.join(' ');

            const utterance = new SpeechSynthesisUtterance(fullText);
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Use selected voice if available
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        // Voice modal handlers
        document.addEventListener('DOMContentLoaded', () => {
            const selectVoiceBtn = document.getElementById('selectVoiceBtn');
            const voiceModal = document.getElementById('voiceModal');
            const closeVoiceModalBtn = document.getElementById('closeVoiceModalBtn');

            selectVoiceBtn.addEventListener('click', () => {
                populateVoiceModal();
                voiceModal.style.display = 'flex';
            });

            closeVoiceModalBtn.addEventListener('click', () => {
                voiceModal.style.display = 'none';
            });

            // Close on background click
            voiceModal.addEventListener('click', (e) => {
                if (e.target === voiceModal) {
                    voiceModal.style.display = 'none';
                }
            });
        });

        // Setup Modal (API Key + Voice) Management
        let apiKey = localStorage.getItem('openai_api_key') || sessionStorage.getItem('openai_api_key') || '';
        const setupModal = document.getElementById('setupModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveSetupBtn = document.getElementById('saveSetupBtn');
        const testVoiceBtn = document.getElementById('testVoiceBtn');
        const changeApiKeyBtn = document.getElementById('changeApiKeyBtn');
        const sessionOnlyCheckbox = document.getElementById('sessionOnlyCheckbox');
        const httpsWarning = document.getElementById('httpsWarning');
        const voiceSelectModal = document.getElementById('voiceSelectModal');

        // Check if using HTTPS
        if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
            httpsWarning.style.display = 'block';
        }

        // Check if API key and voice are already set
        const hasVoice = localStorage.getItem('tts_voice');
        if (apiKey && hasVoice) {
            setupModal.style.display = 'none';
        }

        // Check if user previously selected session-only mode
        const useSessionOnly = localStorage.getItem('use_session_only') === 'true';
        if (useSessionOnly) {
            sessionOnlyCheckbox.checked = true;
        }

        // Test voice button
        testVoiceBtn.addEventListener('click', () => {
            const voiceName = voiceSelectModal.value;
            if (voiceName) {
                const testVoice = availableVoices.find(v => v.name === voiceName);
                const utterance = new SpeechSynthesisUtterance('Hello! This is how I sound.');
                utterance.voice = testVoice;
                utterance.rate = 0.9;
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            } else {
                const utterance = new SpeechSynthesisUtterance('Hello! This is the default voice.');
                utterance.rate = 0.9;
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            }
        });

        saveSetupBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (!key) {
                alert('Please enter a valid API key');
                return;
            }
            if (!key.startsWith('sk-')) {
                alert('Invalid API key format. OpenAI keys start with "sk-"');
                return;
            }

            const voiceSelectModal = document.getElementById('voiceSelectModal');
            const voiceName = voiceSelectModal ? voiceSelectModal.value : '';
            if (!voiceName) {
                alert('Please select a voice for text-to-speech');
                return;
            }

            apiKey = key;

            // Store API key based on user preference
            if (sessionOnlyCheckbox.checked) {
                sessionStorage.setItem('openai_api_key', key);
                localStorage.setItem('use_session_only', 'true');
                localStorage.removeItem('openai_api_key');
            } else {
                localStorage.setItem('openai_api_key', key);
                localStorage.setItem('use_session_only', 'false');
                sessionStorage.removeItem('openai_api_key');
            }

            // Store voice selection
            selectedVoice = availableVoices.find(v => v.name === voiceName);
            localStorage.setItem('tts_voice', voiceName);

            // Update voice button text
            updateVoiceButtonText(voiceName);

            setupModal.style.display = 'none';
            apiKeyInput.value = '';
        });

        changeApiKeyBtn.addEventListener('click', () => {
            setupModal.style.display = 'flex';
            apiKeyInput.value = '';
            apiKeyInput.focus();
        });

        apiKeyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveSetupBtn.click();
            }
        });

        // Main app logic
        let allTerms = [];
        let canvasTerms = [];
        let suggestionsDebounceTimer = null;
        let lastSuggestedWords = '';

        // Category data with emojis and words
        const categories = {
            '🤖 Context': { emoji: '🤖', name: 'Context', words: [] },
            '👤 Pronouns': { emoji: '👤', name: 'Pronouns', words: ['👤 I', '👥 you', '👨 he', '👩 she', '⚡ it', '👫 we', '👥 they', '🙋 me', '🙋‍♂️ him', '🙋‍♀️ her', '🤝 us', '👬 them', '📌 my', '📍 your', '🔹 his', '🔸 her', '⭐ its', '🌟 our', '✨ their', '👉 this', '👈 that', '🔽 these', '🔼 those', '❓ who', '❔ what', '🔀 which', '🏷️ whose'] },
            '❓ Question Words': { emoji: '❓', name: 'Question Words', words: ['❓ who', '❔ what', '⏰ when', '📍 where', '🤔 why', '🛠️ how', '🔀 which', '🏷️ whose', '💰 how much', '🔢 how many', '⏱️ how long', '📏 how far', '🔁 how often'] },
            '📍 Prepositions': { emoji: '📍', name: 'Prepositions', words: ['📥 in', '🔛 on', '📍 at', '👉 by', '🤝 with', '⬅️ from', '➡️ to', '📦 of', '🎁 for', '💭 about', '⬆️ above', '▶️ after', '🚫 against', '🛤️ along', '🎪 among', '🔄 around', '⏪ before', '⬇️ behind', '🔽 below', '⬌ between', '🌌 beyond', '⬇️ down', '⏳ during', '🚷 except', '🏠 inside', '📥 into', '💝 like', '📌 near', '🔌 off', '🚪 out', '🏞️ outside', '🔝 over', '⏮️ past', '📅 since', '🔀 through', '🎯 toward', '⬇️ under', '⏳ until', '⬆️ up', '📦 within', '🚫 without'] },
            '🙏 Politeness': { emoji: '🙏', name: 'Politeness', words: ['🙏 please', '💝 thank you', '🙌 thanks', '😔 sorry', '🙋 excuse me', '🤗 welcome'] },
            '👋 Greetings': { emoji: '👋', name: 'Greetings', words: ['👋 hello', '✋ hi', '🙌 hey', '🌅 good morning', '☀️ good afternoon', '🌆 good evening', '🌙 good night', '👋 goodbye', '✌️ bye', '👀 see you', '💝 take care', '🤝 nice to meet you', '❓ how are you'] },
            '🗺️ Location': { emoji: '🗺️', name: 'Location', words: ['📍 here', '👉 there', '🌍 everywhere', '❓ somewhere', '🗺️ anywhere', '🚫 nowhere', '⬆️ up', '⬇️ down', '⬅️ left', '➡️ right', '▶️ forward', '◀️ backward', '🔜 ahead', '🔙 behind', '📌 nearby', '🌌 far', '🤏 close', '↗️ away', '🔄 around', '🏠 inside', '🌳 outside', '⬆️ upstairs', '⬇️ downstairs', '↔️ next to'] },
            '⏰ Time': { emoji: '⏰', name: 'Time', words: ['⚡ now', '⏰ then', '📅 today', '⏮️ yesterday', '⏭️ tomorrow', '🌙 tonight', '🌅 morning', '☀️ afternoon', '🌆 evening', '🌃 night', '⏰ later', '🔜 soon', '⏰ early', '⌛ late', '⏪ before', '⏩ after', '⏳ during', '⌚ while', '♾️ always', '🚫 never', '🔄 sometimes', '📊 often', '🥉 rarely', '📈 usually', '✅ already', '⏰ yet', '⏸️ still', '⚡ just'] },
            '👁️ Senses': { emoji: '👁️', name: 'Senses', words: ['👁️ see', '👀 look', '📺 watch', '👂 hear', '🎧 listen', '👃 smell', '👅 taste', '🤚 touch', '💭 feel'] },
            '🧠 Thinking & Feeling': { emoji: '🧠', name: 'Thinking & Feeling', words: ['🧠 know', '💭 think', '✨ believe', '💡 understand', '🧠 remember', '🌫️ forget', '📚 learn', '🌈 imagine', '💝 want', '📍 need', '❤️ like', '💖 love', '💔 hate', '💝 care', '⚡ do', '🔨 make', '📦 get', '🤲 take', '🎁 give', '📌 put', '🔧 use', '🔍 find', '👉 show', '🤝 help', '✅ let', '📦 keep', '👋 leave', '▶️ start', '⏹️ stop', '🏁 end', '▶️ continue', '💪 try', '❌ fail', '💼 work', '🎮 play', '😴 rest', '⏰ wait', '📍 stay', '🔄 become', '🔀 change', '🌱 grow', '➕ add', '➖ remove', '📉 lose', '🏆 win', '🛒 buy', '💵 sell', '💸 spend', '💰 save', '🤝 share'] },
            '🚶 Doing & Talking': { emoji: '🚶', name: 'Doing & Talking', words: ['🚶 go', '👋 come', '🏃 move', '🚶 walk', '🏃 run', '🦘 jump', '🧗 climb', '⬇️ fall', '🪑 sit', '🧍 stand', '😴 sleep', '⏰ wake', '🔄 turn', '👉 push', '🤲 pull', '⬆️ lift', '📦 carry', '🤲 hold', '✊ grab', '🤾 catch', '🎯 throw', '👊 hit', '🦵 kick', '🤚 touch', '🤲 reach', '👉 point', '👋 wave', '🚪 open', '🔒 close', '💥 break', '🔧 fix', '🏗️ build', '✨ clean', '🚿 wash', '💨 dry', '👕 wear', '➖ remove', '⬇️ drop', '💬 say', '🗣️ tell', '💬 talk', '❓ ask', '💡 answer', '↩️ reply', '📖 explain', '📝 describe', '📞 call', '📣 shout', '🤫 whisper', '😱 yell', '😂 laugh', '😊 smile', '🍽️ eat', '🥤 drink'] },
            '🔢 Quantity': { emoji: '🔢', name: 'Quantity', words: ['💯 all', '📊 some', '📈 many', '🤏 few', '💯 much', '🤏 little', '➕ more', '➖ less', '🏆 most', '🥉 least', '✅ enough', '🚫 none', '❓ any', '1️⃣ each', '💯 every', '2️⃣ both', '🔀 either', '🚫 neither', '½ half', '💯 whole', '🧩 part', '🧩 piece'] },
            '✨ Describing Words': { emoji: '✨', name: 'Describing Words', words: ['👍 good', '👎 bad', '📏 big', '🤏 small', '📏 long', '📐 short', '🗼 tall', '⬆️ high', '⬇️ low', '↔️ wide', '🚪 narrow', '📚 thick', '📄 thin', '⚖️ heavy', '🪶 light', '🪨 hard', '🧸 soft', '🔥 hot', '❄️ cold', '☀️ warm', '🧊 cool', '✨ new', '📜 old', '👶 young', '⚡ fast', '🐌 slow', '✅ easy', '😰 difficult', '✨ clean', '🗑️ dirty', '😊 nice', '💪 strong', '😔 weak', '💡 bright', '🌑 dark', '📢 loud', '🤫 quiet', '📦 full', '📭 empty', '✅ safe', '⚠️ dangerous'] },
            '🔗 Connectors': { emoji: '🔗', name: 'Connectors', words: ['➕ and', '🔀 or', '❗ but', '↗️ so', '💡 because', '❓ if', '➡️ then', '⏰ while', '🚫 unless', '⏳ until', '📅 since'] },
            '✅ Yes & No': { emoji: '✅', name: 'Yes & No', words: ['✅ yes', '❌ no', '👌 okay', '👍 sure', '😊 fine', '✅ right', '🤔 maybe', '✅ I agree', '❌ I disagree', '🤔 I think so', "🤷 I don't think so"] },
            '📦 Common Nouns': { emoji: '📦', name: 'Common Nouns', words: ['👤 person', '👥 people', '👨 man', '👩 woman', '👶 child', '👨‍👩‍👧‍👦 family', '🤝 friend', '📦 thing', '📍 place', '⏰ time', '📅 day', '📆 year', '🛤️ way', '💼 work', '🏠 home', '🏡 house', '🚪 room', '🚪 door', '🪟 window', '🪑 table', '🪑 chair', '🛏️ bed', '🍽️ food', '💧 water', '💰 money', '📚 book', '📱 phone', '🚗 car', '🏙️ city', '🌍 country', '🌎 world', '💫 life', '✋ hand', '👁️ eye', '😊 face', '🧠 head', '🫀 body', '🧩 part', '↔️ side', '⬅️ back', '⬆️ top', '⬇️ bottom', '🏁 end', '📍 point', '💬 word', '🏷️ name', '🔢 number', '❓ question', '⚠️ problem', '💡 idea', '📖 story'] }
        };

        const wordBank = document.getElementById('wordBank');
        const workspace = document.getElementById('workspace');
        const loading = document.getElementById('loading');
        const searchInput = document.getElementById('searchInput');
        const termCount = document.getElementById('termCount');
        const imageInput = document.getElementById('imageInput');
        const attachImageBtn = document.getElementById('attachImageBtn');
        const speakAllBtn = document.getElementById('speakAllBtn');

        // Initialize with default categories
        displayWordBank();

        // Speak All button handler
        speakAllBtn.addEventListener('click', speakAll);

        // Image upload handling
        attachImageBtn.addEventListener('click', () => {
            imageInput.click();
        });

        imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!apiKey) {
                alert('Please enter your API key first');
                setupModal.style.display = 'flex';
                imageInput.value = '';
                return;
            }

            loading.classList.add('show');
            document.querySelector('.loading-text').textContent = 'Analyzing image to generate contextually relevant vocab. This takes 1-2 minutes right now. It will be much faster in the future with some optimization work.';
            attachImageBtn.disabled = true;

            try {
                const formData = new FormData();
                formData.append('image', file);
                formData.append('api_key', apiKey);

                const response = await fetch(buildUrl('/analyze-image'), {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = 'Failed to analyze image';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (data.success) {
                    // Use the description as context to generate terms
                    await generateTermsFromContext(data.description);
                } else {
                    alert('Error analyzing image: ' + data.error);
                }
            } catch (error) {
                alert('Error analyzing image: ' + error.message);
            } finally {
                loading.classList.remove('show');
                document.querySelector('.loading-text').textContent = 'Generating words...';
                attachImageBtn.disabled = false;
                imageInput.value = ''; // Reset file input
            }
        });

        async function generateTermsFromContext(context) {
            if (!context) {
                alert('No context available');
                return;
            }

            if (!apiKey) {
                alert('Please enter your API key first');
                setupModal.style.display = 'flex';
                return;
            }

            loading.classList.add('show');

            try {
                const response = await fetch(buildUrl('/generate'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ context, api_key: apiKey })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = 'Failed to generate vocabulary';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (data.success) {
                    // Put generated terms in the Context category
                    categories['🤖 Context'].words = data.terms;
                    allTerms = getAllTerms();
                    displayWordBank();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Error generating terms: ' + error.message);
            } finally {
                loading.classList.remove('show');
            }
        }

        function getAllTerms() {
            let terms = [];
            for (let categoryKey in categories) {
                terms = terms.concat(categories[categoryKey].words);
            }
            return terms;
        }

        function displayWordBank(searchQuery = '') {
            wordBank.innerHTML = '';

            for (let categoryKey in categories) {
                const categoryData = categories[categoryKey];
                const categoryTerms = categoryData.words;

                // Filter by search if applicable
                let filteredTerms = categoryTerms;
                if (searchQuery) {
                    filteredTerms = categoryTerms.filter(term =>
                        term.toLowerCase().includes(searchQuery.toLowerCase())
                    );
                }

                // Skip empty categories when searching
                if (searchQuery && filteredTerms.length === 0) continue;

                // Create category
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';

                // Category header
                const header = document.createElement('div');
                header.className = 'category-header';
                header.innerHTML = `
                    <span class="category-icon">${categoryData.emoji}</span>
                    <span class="category-name">${categoryData.name} (${filteredTerms.length})</span>
                    <span class="category-arrow">▶</span>
                `;

                // Category content
                const content = document.createElement('div');
                content.className = 'category-content';

                // Add terms
                filteredTerms.forEach(term => {
                    const card = document.createElement('div');
                    card.className = 'bank-term';
                    card.textContent = term;
                    card.draggable = true;

                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', term);
                        e.dataTransfer.effectAllowed = 'copy';
                    });

                    card.addEventListener('click', () => {
                        addToCanvas(term);
                    });

                    content.appendChild(card);
                });

                // Toggle expand/collapse
                header.addEventListener('click', () => {
                    const arrow = header.querySelector('.category-arrow');
                    const isExpanded = content.classList.contains('expanded');

                    if (isExpanded) {
                        content.classList.remove('expanded');
                        arrow.classList.remove('expanded');
                        header.classList.remove('expanded');
                    } else {
                        content.classList.add('expanded');
                        arrow.classList.add('expanded');
                        header.classList.add('expanded');
                    }
                });

                categoryDiv.appendChild(header);
                categoryDiv.appendChild(content);
                wordBank.appendChild(categoryDiv);
            }

            updateTermCount();
        }

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value;
            displayWordBank(query);
        });

        // Canvas drag and drop
        let draggedCard = null;
        let insertionMarker = null;

        workspace.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = draggedCard ? 'move' : 'copy';
            workspace.classList.add('dragover');

            const afterElement = getDragAfterElement(workspace, e.clientX, e.clientY);

            // Remove existing marker
            if (insertionMarker && !draggedCard) {
                insertionMarker.remove();
                insertionMarker = null;
            }

            if (draggedCard) {
                // Reordering existing card
                if (afterElement == null) {
                    workspace.appendChild(draggedCard);
                } else {
                    workspace.insertBefore(draggedCard, afterElement);
                }
            } else {
                // Show insertion marker for new items
                if (!insertionMarker) {
                    insertionMarker = document.createElement('div');
                    insertionMarker.className = 'insertion-marker';
                }

                if (afterElement == null) {
                    workspace.appendChild(insertionMarker);
                } else {
                    workspace.insertBefore(insertionMarker, afterElement);
                }
            }
        });

        workspace.addEventListener('dragleave', (e) => {
            if (e.target === workspace) {
                workspace.classList.remove('dragover');
                if (insertionMarker) {
                    insertionMarker.remove();
                    insertionMarker = null;
                }
            }
        });

        workspace.addEventListener('drop', (e) => {
            e.preventDefault();
            workspace.classList.remove('dragover');

            // Clean up insertion marker
            if (insertionMarker) {
                insertionMarker.remove();
                insertionMarker = null;
            }

            const term = e.dataTransfer.getData('text/plain');
            if (term && !draggedCard) {
                // Adding from sidebar
                const afterElement = getDragAfterElement(workspace, e.clientX, e.clientY);
                addToCanvas(term, afterElement);
            }

            draggedCard = null;
        });

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.canvas-term:not(.dragging)')];

            let closestElement = null;
            let closestDistance = Infinity;

            draggableElements.forEach(child => {
                const box = child.getBoundingClientRect();
                const centerX = box.left + box.width / 2;
                const centerY = box.top + box.height / 2;

                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

                // If cursor is to the left of the element's center, insert before it
                if (x < centerX && distance < closestDistance) {
                    closestDistance = distance;
                    closestElement = child;
                }
            });

            return closestElement;
        }

        function addToCanvas(term, beforeElement) {
            const card = document.createElement('div');
            card.className = 'canvas-term';
            card.textContent = term;
            card.draggable = true;

            // Click to speak
            card.addEventListener('click', (e) => {
                // Don't speak when clicking remove button
                if (e.target.classList.contains('remove-btn')) return;
                speak(term);
            });

            // Remove button
            const removeBtn = document.createElement('div');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '×';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                card.remove();
                canvasTerms = canvasTerms.filter(t => t.element !== card);

                // Show empty state if no more terms
                const emptyState = workspace.querySelector('.empty-state');
                if (emptyState && canvasTerms.length === 0) {
                    emptyState.style.display = 'block';
                }

                // Update suggestions after removal
                debouncedFetchSuggestions();
            });
            card.appendChild(removeBtn);

            // Drag events for reordering
            card.addEventListener('dragstart', (e) => {
                draggedCard = card;
                card.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
                draggedCard = null;
            });

            // Insert at position or append
            if (beforeElement) {
                workspace.insertBefore(card, beforeElement);
            } else {
                workspace.appendChild(card);
            }

            canvasTerms.push({ term, element: card });

            // Hide empty state
            const emptyState = workspace.querySelector('.empty-state');
            if (emptyState && canvasTerms.length > 0) {
                emptyState.style.display = 'none';
            }

            // Update suggestions after adding
            debouncedFetchSuggestions();
        }

        function updateTermCount() {
            const total = getAllTerms().length;
            termCount.textContent = `${total} words in bank`;
        }

        // Suggestions functionality
        async function fetchSuggestions() {
            const suggestionsList = document.getElementById('suggestionsList');

            // Get current workspace words
            const wordsInWorkspace = Array.from(workspace.querySelectorAll('.canvas-term'))
                .map(el => el.textContent.replace('×', '').trim())
                .map(term => term.replace(/[\u{1F300}-\u{1F9FF}]/gu, '').trim())
                .filter(term => term);

            // Create a key for caching
            const wordsKey = wordsInWorkspace.join(' ');

            // Don't refetch if same words
            if (wordsKey === lastSuggestedWords) {
                return;
            }
            lastSuggestedWords = wordsKey;

            // Show loading state
            suggestionsList.innerHTML = '<div class="suggestions-loading">Loading suggestions...</div>';

            try {
                const response = await fetch(buildUrl('/suggest-next-words'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        words: wordsInWorkspace,
                        api_key: apiKey
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch suggestions');
                }

                const data = await response.json();

                if (data.success && data.suggestions) {
                    displaySuggestions(data.suggestions);
                } else {
                    suggestionsList.innerHTML = '<div class="suggestions-empty">No suggestions available</div>';
                }
            } catch (error) {
                console.error('Error fetching suggestions:', error);
                suggestionsList.innerHTML = '<div class="suggestions-empty">Error loading suggestions</div>';
            }
        }

        function displaySuggestions(suggestions) {
            const suggestionsList = document.getElementById('suggestionsList');
            suggestionsList.innerHTML = '';

            suggestions.forEach(word => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = word;
                item.draggable = true;

                // Click to add to workspace
                item.addEventListener('click', () => {
                    addToCanvas(word);
                    // Update suggestions after adding
                    debouncedFetchSuggestions();
                });

                // Drag events
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', word);
                    item.style.opacity = '0.5';
                });

                item.addEventListener('dragend', (e) => {
                    item.style.opacity = '1';
                });

                suggestionsList.appendChild(item);
            });
        }

        function debouncedFetchSuggestions() {
            // Clear existing timer
            if (suggestionsDebounceTimer) {
                clearTimeout(suggestionsDebounceTimer);
            }

            // Set new timer for 1 second
            suggestionsDebounceTimer = setTimeout(() => {
                fetchSuggestions();
            }, 1000);
        }

        // Fetch suggestions on page load (empty workspace = core vocab)
        setTimeout(() => {
            if (apiKey) {
                fetchSuggestions();
            }
        }, 1000);

        // Sentence generation
        const generateSentencesBtn = document.getElementById('generateSentencesBtn');
        const sentencesList = document.getElementById('sentencesList');

        generateSentencesBtn.addEventListener('click', async () => {
            // Get words from workspace in order
            const wordsInWorkspace = Array.from(workspace.querySelectorAll('.canvas-term'))
                .map(el => el.textContent.replace('×', '').trim());

            if (wordsInWorkspace.length === 0) {
                alert('Add some words to the workspace first!');
                return;
            }

            if (!apiKey) {
                alert('Please enter your API key first');
                setupModal.style.display = 'flex';
                return;
            }

            generateSentencesBtn.disabled = true;
            generateSentencesBtn.textContent = 'Generating...';
            sentencesList.innerHTML = '<div class="sentences-empty">Generating sentences...</div>';

            try {
                const response = await fetch(buildUrl('/generate-sentences'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ words: wordsInWorkspace, api_key: apiKey })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = 'Failed to generate sentences';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (data.success && data.sentences) {
                    sentencesList.innerHTML = '';
                    data.sentences.forEach(sentence => {
                        const sentenceItem = document.createElement('div');
                        sentenceItem.className = 'sentence-item';
                        sentenceItem.textContent = sentence;

                        // Click to speak sentence
                        sentenceItem.addEventListener('click', () => {
                            speak(sentence);
                        });

                        sentencesList.appendChild(sentenceItem);
                    });
                } else {
                    sentencesList.innerHTML = '<div class="sentences-empty">Error generating sentences. Please try again.</div>';
                }
            } catch (error) {
                console.error('Error:', error);
                sentencesList.innerHTML = '<div class="sentences-empty">Error generating sentences. Please try again.</div>';
            } finally {
                generateSentencesBtn.disabled = false;
                generateSentencesBtn.textContent = 'Create Sentences';
            }
        });

        // Focus functionality
        const sidebar = document.getElementById('sidebar');
        const sentencesPanel = document.getElementById('sentencesPanel');
        const focusWordsBtn = document.getElementById('focusWordsBtn');
        const focusSentencesBtn = document.getElementById('focusSentencesBtn');

        focusWordsBtn.addEventListener('click', () => {
            const isFocused = sidebar.classList.contains('focused');

            if (isFocused) {
                sidebar.classList.remove('focused');
                focusWordsBtn.classList.remove('active');
                focusWordsBtn.textContent = '⇄';
            } else {
                sidebar.classList.add('focused');
                sentencesPanel.classList.remove('focused');
                focusWordsBtn.classList.add('active');
                focusSentencesBtn.classList.remove('active');
                focusWordsBtn.textContent = '⇆';
                focusSentencesBtn.textContent = '⇄';
            }
        });

        focusSentencesBtn.addEventListener('click', () => {
            const isFocused = sentencesPanel.classList.contains('focused');

            if (isFocused) {
                sentencesPanel.classList.remove('focused');
                focusSentencesBtn.classList.remove('active');
                focusSentencesBtn.textContent = '⇄';
            } else {
                sentencesPanel.classList.add('focused');
                sidebar.classList.remove('focused');
                focusSentencesBtn.classList.add('active');
                focusWordsBtn.classList.remove('active');
                focusSentencesBtn.textContent = '⇆';
                focusWordsBtn.textContent = '⇄';
            }
        });
    </script>
</body>
</html>
