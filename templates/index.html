<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>AI-AAC</title>
    <script>
        window.APP_CONFIG = {
            basePath: {{ base_path|tojson }}
        };
    </script>
    <style>
        :root {
            --primary: #5465ff;
            --primary-hover: #3f53ec;
            --surface: rgba(255, 255, 255, 0.98);
            --surface-muted: #f2f4ff;
            --surface-strong: #ffffff;
            --border: rgba(84, 101, 255, 0.18);
            --border-strong: rgba(84, 101, 255, 0.32);
            --text-strong: #0f172a;
            --text-muted: #636f88;
            --shadow-lg: 0 28px 60px rgba(15, 23, 42, 0.08);
            --shadow-sm: 0 12px 30px rgba(84, 101, 255, 0.12);
            --radius-lg: 28px;
            --radius-md: 20px;
            --radius-sm: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Arial, sans-serif;
            background: linear-gradient(180deg, #e8efff 0%, #f9fbff 100%);
            color: var(--text-strong);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for iOS Safari */
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: stretch;
            padding: 16px;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-y;
        }

        h1, h2, h3 {
            font-weight: 700;
        }

        button {
            font: inherit;
        }

        .app-shell {
            max-width: 1280px;
            width: 100%;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 18px;
            display: flex;
            gap: 20px;
            align-items: stretch;
            min-height: 0;
            height: 100%;
            box-shadow: var(--shadow-lg);
        }

        /* Sidebar - Word Bank */
        .sidebar {
            flex: 0 0 320px;
            background: var(--surface-muted);
            display: flex;
            flex-direction: column;
            gap: 14px;
            border-radius: var(--radius-md);
            padding: 18px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            transition: flex-basis 0.3s ease;
            height: 100%;
            min-height: 0;
            overflow: hidden;
        }

        .sidebar.focused {
            flex-basis: min(520px, 55%);
        }

        .sidebar-header {
            display: flex;
            flex-direction: column;
            gap: 18px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .focus-btn {
            min-width: 44px;
            min-height: 44px;
            width: 44px;
            height: 44px;
            background: var(--surface-strong);
            border: 1px solid var(--border-strong);
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        .focus-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 25px rgba(84, 101, 255, 0.22);
        }

        .focus-btn.active {
            background: var(--primary);
            color: white;
            border-color: transparent;
        }

        .input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .search-box {
            padding-top: 10px;
            border-top: 1px dashed rgba(84, 101, 255, 0.16);
            flex-shrink: 0;
        }

        .search-box input[type="text"] {
            margin-top: 10px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: var(--surface-strong);
            font-size: 15px;
            outline: none;
            transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            color: var(--text-strong);
        }

        input[type="text"]::placeholder {
            color: #9ba5c0;
        }

        input[type="text"]:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(84, 101, 255, 0.18);
            background: #ffffff;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 18px;
            border-radius: var(--radius-sm);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid transparent;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: var(--primary);
            color: #ffffff;
            box-shadow: var(--shadow-sm);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 18px 32px rgba(84, 101, 255, 0.28);
        }

        .word-bank {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }

        .word-bank::-webkit-scrollbar,
        .sentences-list::-webkit-scrollbar {
            width: 10px;
        }

        .word-bank::-webkit-scrollbar-thumb,
        .sentences-list::-webkit-scrollbar-thumb {
            background: rgba(84, 101, 255, 0.2);
            border-radius: 20px;
        }

        .word-bank::-webkit-scrollbar-track,
        .sentences-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .category {
            background: var(--surface-strong);
            border-radius: var(--radius-sm);
            border: 1px solid transparent;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .category:hover {
            border-color: var(--border);
            box-shadow: 0 16px 30px rgba(84, 101, 255, 0.12);
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            color: var(--text-strong);
            border-radius: var(--radius-sm);
            cursor: pointer;
            user-select: none;
            font-size: 15px;
            font-weight: 600;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .category-header:hover {
            background: rgba(84, 101, 255, 0.08);
        }

        .category-header.expanded {
            background: rgba(84, 101, 255, 0.12);
            color: var(--primary);
        }

        .category-icon {
            font-size: 18px;
            flex-shrink: 0;
            width: 24px;
            text-align: center;
        }

        .category-name {
            flex: 1;
        }

        .category-arrow {
            transition: transform 0.2s ease;
            font-size: 11px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .category-arrow.expanded {
            transform: rotate(90deg);
        }

        .category-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.35s ease;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 0 10px;
        }

        .category-content.expanded {
            max-height: 3000px;
            padding: 10px;
        }

        .bank-term {
            background: var(--surface-muted);
            padding: 12px 16px;
            min-height: 44px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 1px solid transparent;
            user-select: none;
            -webkit-user-select: none;
            font-size: 15px;
            font-weight: 500;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
            white-space: nowrap;
            box-shadow: 0 8px 18px rgba(84, 101, 255, 0.12);
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bank-term:hover {
            background: rgba(84, 101, 255, 0.15);
            border-color: rgba(84, 101, 255, 0.35);
            transform: translateY(-2px);
            box-shadow: 0 16px 30px rgba(84, 101, 255, 0.18);
        }

        .bank-term:active, .bank-term.touching {
            cursor: grabbing;
            transform: scale(0.98);
            background: rgba(84, 101, 255, 0.25);
            box-shadow: 0 4px 12px rgba(84, 101, 255, 0.2);
        }

        .term-count {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px dashed rgba(84, 101, 255, 0.2);
            font-size: 13px;
            color: var(--text-muted);
            text-align: center;
            flex-shrink: 0;
        }

        /* Main Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            gap: 18px;
            align-items: stretch;
            min-height: 0;
        }

        .workspace-suggestions-wrapper {
            flex: 1 1 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            min-width: 0;
            max-width: 100%;
            width: 0;
        }

        .workspace-column {
            flex: 1;
            background: var(--surface-muted);
            border-radius: var(--radius-md);
            padding: 18px 18px 22px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: relative;
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }

        .workspace-heading {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .workspace-heading h2 {
            font-size: 20px;
            letter-spacing: -0.01em;
        }

        .workspace {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-content: flex-start;
            padding: 20px;
            background: var(--surface-strong);
            border-radius: var(--radius-md);
            border: 2px dashed rgba(84, 101, 255, 0.18);
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: inset 0 1px 4px rgba(84, 101, 255, 0.08);
        }

        .workspace.dragover {
            background: rgba(84, 101, 255, 0.08);
            border-color: rgba(84, 101, 255, 0.38);
            box-shadow: inset 0 0 0 3px rgba(84, 101, 255, 0.18);
        }

        .canvas-term {
            position: relative;
            background: #eef0ff;
            padding: 12px 20px;
            min-height: 48px;
            border-radius: 18px;
            box-shadow: 0 12px 20px rgba(84, 101, 255, 0.18);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            border: 1px solid rgba(84, 101, 255, 0.35);
            flex-shrink: 0;
            color: #363dcc;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-term:hover {
            transform: translateY(-2px);
            background: #dde1ff;
            box-shadow: 0 18px 28px rgba(84, 101, 255, 0.24);
        }

        .canvas-term:hover::before {
            content: 'üîä';
            position: absolute;
            top: -10px;
            left: -10px;
            font-size: 16px;
            background: white;
            border-radius: 50%;
            padding: 4px;
            box-shadow: 0 4px 12px rgba(84, 101, 255, 0.3);
        }

        .canvas-term:active, .canvas-term.touching {
            cursor: grabbing;
            transform: scale(0.98);
            background: #c7d1ff;
        }

        .canvas-term.dragging {
            opacity: 0.55;
        }

        .canvas-term .remove-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            min-width: 32px;
            min-height: 32px;
            width: 32px;
            height: 32px;
            background: #ff5d72;
            border: 3px solid white;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
            box-shadow: 0 10px 18px rgba(255, 93, 114, 0.3);
            z-index: 10;
            -webkit-tap-highlight-color: transparent;
        }

        .canvas-term:hover .remove-btn,
        .canvas-term.show-remove .remove-btn {
            display: flex;
        }

        /* Touch devices: always show remove button for better UX */
        @media (hover: none) and (pointer: coarse) {
            .canvas-term .remove-btn {
                display: flex;
                opacity: 0.9;
            }
        }

        /* Touch drag ghost element styling */
        .dragging-ghost {
            pointer-events: none;
            filter: drop-shadow(0 20px 40px rgba(84, 101, 255, 0.35));
        }

        /* Prevent text selection during touch drag */
        body.touching {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Smooth scrolling for iOS */
        .word-bank,
        .sentences-list,
        .suggestions-list {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        /* Touch-friendly improvements for all touch devices */
        @media (hover: none) and (pointer: coarse) {
            /* Increase button sizes for touch */
            .btn {
                min-height: 48px;
                padding: 14px 22px;
                font-size: 16px;
            }

            /* Make category headers easier to tap */
            .category-header {
                padding: 14px 16px;
                font-size: 16px;
            }

            /* Increase tap area for sentence items */
            .sentence-item {
                padding: 16px 20px;
                font-size: 16px;
            }

            /* Better spacing in workspace */
            .workspace {
                gap: 14px;
            }

            /* Make empty state larger and more visible */
            .empty-state {
                font-size: 18px;
            }

            .empty-state-icon {
                font-size: 52px;
            }
        }

        .insertion-marker {
            width: 3px;
            min-height: 50px;
            background: var(--primary);
            border-radius: 3px;
            flex-shrink: 0;
            opacity: 0.7;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
            font-size: 16px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .empty-state-icon {
            font-size: 42px;
        }

        /* Suggestions Panel */
        .suggestions-panel {
            background: var(--surface-muted);
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-radius: var(--radius-md);
            padding: 10px 14px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            min-width: 0;
            overflow: hidden;
        }

        .suggestions-header {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-strong);
            flex-shrink: 0;
            line-height: 1.2;
        }

        .suggestions-list {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 8px;
            min-height: 0;
            padding-bottom: 4px;
            align-items: flex-start;
            width: 100%;
        }

        .suggestions-list::-webkit-scrollbar {
            height: 8px;
        }

        .suggestions-list::-webkit-scrollbar-thumb {
            background: rgba(84, 101, 255, 0.2);
            border-radius: 20px;
        }

        .suggestions-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .suggestion-item {
            padding: 6px 12px;
            background: var(--surface-strong);
            border-radius: var(--radius-sm);
            box-shadow: 0 4px 12px rgba(84, 101, 255, 0.12);
            font-size: 13px;
            color: var(--text-strong);
            border: 1px solid rgba(84, 101, 255, 0.18);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease, opacity 0.2s ease;
            cursor: grab;
            font-weight: 500;
            white-space: nowrap;
            flex-shrink: 0;
            height: fit-content;
            user-select: none;
        }

        .suggestion-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(84, 101, 255, 0.2);
            border-color: rgba(84, 101, 255, 0.35);
            background: #f8f9ff;
        }

        .suggestion-item:active {
            cursor: grabbing;
        }

        .suggestions-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
            padding: 10px 12px;
            background: rgba(84, 101, 255, 0.06);
            border-radius: var(--radius-sm);
            border: 1px dashed rgba(84, 101, 255, 0.2);
            line-height: 1.4;
            white-space: nowrap;
        }

        .suggestions-loading {
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
            padding: 10px 12px;
            font-style: italic;
            white-space: nowrap;
        }

        /* Sentences Panel */
        .sentences-panel {
            flex: 0 0 320px;
            background: var(--surface-muted);
            display: flex;
            flex-direction: column;
            gap: 16px;
            border-radius: var(--radius-md);
            padding: 18px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            transition: flex-basis 0.3s ease;
            height: 100%;
            min-height: 0;
            overflow: hidden;
        }

        .sentences-panel.focused {
            flex-basis: min(520px, 55%);
        }

        .sentences-header-box {
            display: flex;
            flex-direction: column;
            gap: 14px;
            flex-shrink: 0;
        }

        .sentences-header {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-strong);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sentences-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }

        .sentence-item {
            position: relative;
            padding: 12px 16px;
            background: var(--surface-strong);
            border-radius: var(--radius-sm);
            box-shadow: 0 10px 24px rgba(84, 101, 255, 0.14);
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-strong);
            border: 1px solid rgba(84, 101, 255, 0.22);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
            cursor: pointer;
        }

        .sentence-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 18px 30px rgba(84, 101, 255, 0.22);
            border-color: rgba(84, 101, 255, 0.35);
        }

        .sentence-item:hover::after {
            content: 'üîä';
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            font-size: 18px;
            opacity: 0.7;
        }

        .sentences-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            padding: 24px 16px;
            background: rgba(84, 101, 255, 0.08);
            border-radius: var(--radius-sm);
            border: 1px dashed rgba(84, 101, 255, 0.25);
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 250, 255, 0.78);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading.show {
            display: flex;
        }

        .loading-card {
            background: var(--surface);
            border-radius: var(--radius-md);
            padding: 32px 40px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(84, 101, 255, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 18px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-strong);
            font-size: 16px;
            font-weight: 600;
        }

        .progress-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin-bottom: 6px;
            border-radius: 6px;
            background: var(--surface-muted);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .progress-item.completed {
            background: #e8f5e9;
        }

        .progress-item.in-progress {
            background: #fff9e6;
            font-weight: 600;
        }

        .progress-icon {
            font-size: 18px;
            min-width: 24px;
            text-align: center;
        }

        .progress-label {
            color: var(--text-strong);
        }

        .progress-item.completed .progress-icon {
            animation: checkmark 0.3s ease;
        }

        @keyframes checkmark {
            0% { transform: scale(0.5); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* iPad-specific optimizations */
        @media (min-width: 768px) and (max-width: 834px) and (orientation: portrait) {
            body {
                padding: 12px;
            }

            .container {
                padding: 14px;
                gap: 14px;
            }

            .sidebar {
                flex: 0 0 280px;
            }

            .sidebar.focused {
                flex-basis: 420px;
            }

            .sentences-panel {
                flex: 0 0 280px;
            }

            .sentences-panel.focused {
                flex-basis: 420px;
            }

            .workspace {
                padding: 18px;
            }

            .bank-term {
                padding: 14px 18px;
                font-size: 16px;
            }

            .canvas-term {
                padding: 14px 22px;
                font-size: 17px;
            }

            .btn {
                padding: 14px 20px;
                font-size: 16px;
            }
        }

        @media (min-width: 1024px) and (max-width: 1194px) and (orientation: landscape) {
            body {
                padding: 14px;
            }

            .container {
                padding: 16px;
                gap: 16px;
            }

            .sidebar {
                flex: 0 0 300px;
            }

            .sidebar.focused {
                flex-basis: 460px;
            }

            .sentences-panel {
                flex: 0 0 300px;
            }

            .sentences-panel.focused {
                flex-basis: 460px;
            }
        }

        /* Tablet and mobile */
        @media (max-width: 1023px) {
            body {
                height: auto;
                min-height: 100vh;
                overflow-y: auto;
                padding: 12px;
            }

            .app-shell {
                height: auto;
            }

            .container {
                flex-direction: column;
                height: auto;
                padding: 16px;
            }

            .canvas-area {
                flex-direction: column;
                min-height: auto;
            }

            .workspace-suggestions-wrapper {
                width: 100%;
                min-width: 100%;
            }

            .workspace-column,
            .suggestions-panel {
                width: 100%;
            }

            .suggestions-panel {
                flex: 1 1 auto;
                height: auto;
                min-height: auto;
            }

            .suggestions-list {
                flex-wrap: wrap;
                overflow-x: hidden;
                overflow-y: auto;
            }

            .workspace {
                min-height: 220px;
            }

            .sidebar,
            .sidebar.focused,
            .sentences-panel,
            .sentences-panel.focused {
                flex: 1 1 auto;
                width: 100%;
                height: auto;
            }

            .workspace-column {
                order: 2;
                height: auto;
            }

            .sentences-panel {
                order: 3;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 8px;
            }

            .container {
                padding: 16px;
            }

            .workspace {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Modal (Voice Selection) -->
    <div id="setupModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(15, 23, 42, 0.7); display: flex; align-items: center; justify-content: center; z-index: 2000;">
        <div style="background: var(--surface); border-radius: var(--radius-md); padding: 32px; max-width: 500px; width: 90%; max-height: 85vh; overflow-y: auto; border: 1px solid var(--border); box-shadow: var(--shadow-lg);">
            <h2 style="margin-bottom: 16px; font-size: 24px;">Welcome to AI-AAC! üí¨</h2>

            <!-- App Description -->
            <div style="background: linear-gradient(135deg, #f0f4ff 0%, #e8edff 100%); border: 1px solid #5465ff; border-radius: var(--radius-sm); padding: 16px; margin-bottom: 20px;">
                <h3 style="font-size: 16px; font-weight: 700; color: var(--text-strong); margin-bottom: 8px;">About This App</h3>
                <p style="font-size: 14px; color: var(--text-strong); line-height: 1.6; margin-bottom: 12px;">
                    This is a demo of an AI-assisted AAC software designed to be an assistive technology for nonverbal communicators.
                </p>
                <p style="font-size: 14px; color: var(--text-strong); line-height: 1.6; margin-bottom: 12px;">
                    <strong>The Problem:</strong> Currently, AAC softwares provide ~50 words at a time, unchanging by context and are woefully inadequate for communication. There are hundreds of reasons a person may be nonverbal, and almost none of them involve an impairment in language comprehension.
                </p>
                <p style="font-size: 14px; color: var(--text-strong); line-height: 1.6; margin-bottom: 12px;">
                    <strong>The Solution:</strong> Context-dependent suggestions make picking words easier, and the "generate sentences" button lets you choose from nuanced variations of what you want to say. You can also send a photo to generate ~100 context-relevant vocabulary words for your current situation!
                </p>
                <p style="font-size: 14px; color: var(--text-strong); line-height: 1.6; margin: 0;">
                    <strong>The Team:</strong> Built by <a href="https://prosodic.net" target="_blank" style="color: var(--primary); text-decoration: underline;">Sam Lederer</a> (Computational Linguistics), <a href="https://www.linkedin.com/in/liz-m-weber/" target="_blank" style="color: var(--primary); text-decoration: underline;">Elizabeth Weber</a> (Bioengineering), and <a href="https://www.linkedin.com/in/meetapandit/" target="_blank" style="color: var(--primary); text-decoration: underline;">Meeta Pandit</a> (Data Engineering). This was a truly interdisciplinary project that couldn't have been explored without all three of our very different skill sets. We enjoyed connecting with everyone at the hackathon and are open to new opportunities. Feel free to reach out!
                </p>
            </div>

            <!-- Contact Section -->
            <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: var(--radius-sm); padding: 14px; margin-bottom: 20px;">
                <p style="font-size: 13px; color: var(--text-strong); line-height: 1.5; margin: 0;">
                    üí° <strong>Interested in this project?</strong> Elizabeth Weber is actively leading the continued development of this assistive technology. To collaborate or learn more, contact her at <a href="mailto:lizweber2021@gmail.com" style="color: #0ea5e9; text-decoration: underline;">lizweber2021@gmail.com</a>
                </p>
            </div>

            <p style="margin-bottom: 16px; color: var(--text-muted); line-height: 1.6; font-size: 14px;">
                To get started, please select a voice for text-to-speech.
            </p>

            <!-- Voice Selection -->
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-size: 14px; font-weight: 600; color: var(--text-strong);">
                    üîä Select Voice:
                </label>
                <select id="voiceSelectModal" style="width: 100%; padding: 12px 16px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--surface-strong); font-size: 15px; cursor: pointer;">
                    <option value="">Loading voices...</option>
                </select>
                <button id="testVoiceBtn" class="btn" style="margin-top: 8px; width: 100%; background: #f0f4ff; color: var(--primary); border: 1px solid var(--border);">üîä Test Voice</button>
            </div>

            <div style="display: flex; gap: 12px;">
                <button id="saveSetupBtn" class="btn btn-primary" style="flex: 1;">Continue</button>
            </div>
        </div>
    </div>

    <!-- Voice Selection Modal -->
    <div id="voiceModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(15, 23, 42, 0.7); display: none; align-items: center; justify-content: center; z-index: 2000;">
        <div style="background: var(--surface); border-radius: var(--radius-md); padding: 32px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; border: 1px solid var(--border); box-shadow: var(--shadow-lg);">
            <h2 style="margin-bottom: 16px; font-size: 24px;">üîä Select Voice</h2>
            <p style="margin-bottom: 16px; color: var(--text-muted); font-size: 14px;">
                Choose a voice for text-to-speech. Click "Test" to hear a sample.
            </p>

            <div id="voiceList" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;">
                <!-- Voice items will be populated here -->
            </div>

            <div style="display: flex; gap: 12px;">
                <button id="closeVoiceModalBtn" class="btn" style="flex: 1; background: #f0f4ff; color: var(--primary); border: 1px solid var(--border);">Cancel</button>
            </div>
        </div>
    </div>

    <div class="app-shell">
        <div class="container">
            <!-- Sidebar Word Bank -->
            <div class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <div style="display: flex; flex-direction: column; gap: 8px; width: 100%;">
                        <div style="font-size: 20px; font-weight: 700; color: var(--text-strong);">Word Bank</div>
                        <div style="display: flex; gap: 8px; justify-content: flex-start;">
                            <input type="file" id="imageInput" accept="image/*" style="display: none;">
                            <button class="focus-btn" id="attachImageBtn" title="Attach Image" style="font-size: 14px; display: flex; align-items: center; gap: 6px; width: auto; padding: 0 12px; white-space: nowrap;">üì∑ Add Context</button>
                            <button class="focus-btn" id="changeVoiceBtn" title="Change Voice" style="font-size: 14px;">üîä</button>
                            <button class="focus-btn" id="focusWordsBtn">‚Üí</button>
                        </div>
                    </div>
                </div>

                <div class="search-box">
                    <input
                        type="text"
                        id="searchInput"
                        placeholder="Search words"
                    />
                </div>

                <div class="word-bank" id="wordBank"></div>

                <div class="term-count">
                    <span id="termCount">0 words in bank</span>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="workspace-suggestions-wrapper">
                    <div class="workspace-column">
                        <div class="workspace-heading">
                            <h2>Workspace</h2>
                            <button class="btn" id="speakAllBtn" style="padding: 8px 16px; font-size: 14px; background: var(--surface-muted); color: var(--text-strong); border: 1px solid var(--border);">üîä</button>
                        </div>

                        <div class="workspace" id="workspace">
                            <div class="empty-state">
                                <div class="empty-state-icon">üí¨</div>
                                <div>Workspace empty</div>
                            </div>
                        </div>
                    </div>

                    <!-- Suggestions Panel -->
                    <div class="suggestions-panel" id="suggestionsPanel">
                        <div class="suggestions-header">
                            <span>üí° Suggested Next</span>
                        </div>
                        <div class="suggestions-list" id="suggestionsList">
                            <div class="suggestions-empty">Add words to workspace to see suggestions</div>
                        </div>
                    </div>
                </div>

                <!-- Sentences Panel -->
                <div class="sentences-panel" id="sentencesPanel">
                    <div class="sentences-header-box">
                        <div class="sentences-header">
                            <span>Sentences</span>
                            <button class="focus-btn" id="focusSentencesBtn">‚Üê</button>
                        </div>
                        <button class="btn btn-primary" id="generateSentencesBtn">Create Sentences</button>
                    </div>
                    <div class="sentences-list" id="sentencesList">
                        <div class="sentences-empty">No sentences yet.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="loading-card">
            <div class="spinner"></div>
            <div class="loading-text">Generating words...</div>
            <div id="progressChecklist" style="display: none; margin-top: 20px; text-align: left; max-width: 400px;">
                <div class="progress-item" data-stage="1">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Analyzing image</span>
                </div>
                <div class="progress-item" data-stage="2">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Embedding context</span>
                </div>
                <div class="progress-item" data-stage="3">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Generating candidate terms</span>
                </div>
                <div class="progress-item" data-stage="4">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Normalizing and deduplicating</span>
                </div>
                <div class="progress-item" data-stage="5">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Computing term vectors</span>
                </div>
                <div class="progress-item" data-stage="6">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Computing relevance signals</span>
                </div>
                <div class="progress-item" data-stage="7">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Scoring terms</span>
                </div>
                <div class="progress-item" data-stage="8">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Categorizing terms</span>
                </div>
                <div class="progress-item" data-stage="9">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Ensuring variety</span>
                </div>
                <div class="progress-item" data-stage="10">
                    <span class="progress-icon">‚è≥</span>
                    <span class="progress-label">Adding emojis</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const normalizeBasePath = (path) => {
            if (!path || path === '/') {
                return '';
            }
            return path.endsWith('/') ? path.slice(0, -1) : path;
        };

        const BASE_PATH = normalizeBasePath(window.APP_CONFIG?.basePath);
        const buildUrl = (endpoint) => `${BASE_PATH}${endpoint}`;

        // Touch device detection
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const isIPad = /iPad|Macintosh/.test(navigator.userAgent) && 'ontouchend' in document;
        const TOUCH_DRAG_THRESHOLD = 12; // px movement before we treat touch as a drag

        // Text-to-Speech functionality
        let selectedVoice = null;
        let availableVoices = [];

        function populateVoiceModal() {
            const voiceList = document.getElementById('voiceList');
            if (!voiceList || availableVoices.length === 0) return;

            // Clear existing items
            voiceList.innerHTML = '';

            // Get saved voice
            const savedVoiceName = localStorage.getItem('tts_voice');

            // Add default option
            const defaultItem = createVoiceItem(null, 'Default Voice', 'System default', savedVoiceName === null || savedVoiceName === '');
            voiceList.appendChild(defaultItem);

            // Add voices, prioritizing English voices
            const englishVoices = availableVoices.filter(v => v.lang.startsWith('en'));
            const otherVoices = availableVoices.filter(v => !v.lang.startsWith('en'));

            if (englishVoices.length > 0) {
                const englishHeader = document.createElement('div');
                englishHeader.style.cssText = 'font-size: 12px; font-weight: 700; color: var(--text-muted); margin-top: 12px; margin-bottom: 4px;';
                englishHeader.textContent = 'English Voices';
                voiceList.appendChild(englishHeader);

                englishVoices.forEach(voice => {
                    const item = createVoiceItem(voice, voice.name, voice.lang, savedVoiceName === voice.name);
                    voiceList.appendChild(item);
                });
            }

            if (otherVoices.length > 0) {
                const otherHeader = document.createElement('div');
                otherHeader.style.cssText = 'font-size: 12px; font-weight: 700; color: var(--text-muted); margin-top: 12px; margin-bottom: 4px;';
                otherHeader.textContent = 'Other Languages';
                voiceList.appendChild(otherHeader);

                otherVoices.forEach(voice => {
                    const item = createVoiceItem(voice, voice.name, voice.lang, savedVoiceName === voice.name);
                    voiceList.appendChild(item);
                });
            }
        }

        function createVoiceItem(voice, name, lang, isSelected) {
            const item = document.createElement('div');
            item.style.cssText = `
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 12px;
                background: ${isSelected ? '#f0f4ff' : 'var(--surface-strong)'};
                border: 1px solid ${isSelected ? 'var(--primary)' : 'var(--border)'};
                border-radius: var(--radius-sm);
                cursor: pointer;
                transition: all 0.2s ease;
            `;

            const info = document.createElement('div');
            info.style.cssText = 'flex: 1;';
            info.innerHTML = `
                <div style="font-weight: 600; font-size: 14px; color: var(--text-strong);">${name}</div>
                <div style="font-size: 12px; color: var(--text-muted);">${lang}</div>
            `;

            const testBtn = document.createElement('button');
            testBtn.className = 'btn';
            testBtn.style.cssText = 'padding: 6px 12px; font-size: 13px; background: #f0f4ff; color: var(--primary); border: 1px solid var(--border);';
            testBtn.textContent = 'üîä Test';
            testBtn.onclick = (e) => {
                e.stopPropagation();
                testVoice(voice);
            };

            const selectBtn = document.createElement('button');
            selectBtn.className = 'btn btn-primary';
            selectBtn.style.cssText = 'padding: 6px 16px; font-size: 13px;';
            selectBtn.textContent = isSelected ? '‚úì Selected' : 'Select';
            if (isSelected) {
                selectBtn.style.opacity = '0.7';
            }

            item.appendChild(info);
            item.appendChild(testBtn);
            item.appendChild(selectBtn);

            // Click to select
            item.onclick = () => {
                selectVoice(voice);
                document.getElementById('voiceModal').style.display = 'none';
            };

            return item;
        }

        function testVoice(voice) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance('Hello! This is how I sound.');
            if (voice) {
                utterance.voice = voice;
            }
            utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
        }

        function selectVoice(voice) {
            if (voice) {
                selectedVoice = voice;
                localStorage.setItem('tts_voice', voice.name);
            } else {
                selectedVoice = null;
                localStorage.removeItem('tts_voice');
            }
        }


        function loadVoices() {
            availableVoices = window.speechSynthesis.getVoices();

            // Populate modal dropdown
            const voiceSelectModal = document.getElementById('voiceSelectModal');

            if (availableVoices.length > 0) {
                if (voiceSelectModal) {
                    populateVoiceSelect(voiceSelectModal);
                }

                // Load saved voice preference
                const savedVoice = localStorage.getItem('tts_voice');
                if (savedVoice) {
                    selectedVoice = availableVoices.find(v => v.name === savedVoice);
                    if (voiceSelectModal) {
                        voiceSelectModal.value = savedVoice;
                    }
                }
            }
        }

        function populateVoiceSelect(selectElement) {
            if (availableVoices.length === 0) return;

            // Clear existing options
            selectElement.innerHTML = '';

            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'üîä Default Voice';
            selectElement.appendChild(defaultOption);

            // Add voices
            const englishVoices = availableVoices.filter(v => v.lang.startsWith('en'));
            const otherVoices = availableVoices.filter(v => !v.lang.startsWith('en'));

            if (englishVoices.length > 0) {
                const englishGroup = document.createElement('optgroup');
                englishGroup.label = 'English';
                englishVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    englishGroup.appendChild(option);
                });
                selectElement.appendChild(englishGroup);
            }

            if (otherVoices.length > 0) {
                const otherGroup = document.createElement('optgroup');
                otherGroup.label = 'Other Languages';
                otherVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    otherGroup.appendChild(option);
                });
                selectElement.appendChild(otherGroup);
            }
        }

        // Load voices when they're ready
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }
        loadVoices(); // Call immediately in case voices are already loaded

        function removeAllEmojis(text) {
            // Comprehensive emoji removal - covers all emoji ranges
            return text.replace(/[\u{1F600}-\u{1F64F}]/gu, '') // Emoticons
                       .replace(/[\u{1F300}-\u{1F5FF}]/gu, '') // Misc Symbols and Pictographs
                       .replace(/[\u{1F680}-\u{1F6FF}]/gu, '') // Transport and Map
                       .replace(/[\u{1F1E0}-\u{1F1FF}]/gu, '') // Flags
                       .replace(/[\u{2600}-\u{26FF}]/gu, '')   // Misc symbols
                       .replace(/[\u{2700}-\u{27BF}]/gu, '')   // Dingbats
                       .replace(/[\u{1F900}-\u{1F9FF}]/gu, '') // Supplemental Symbols and Pictographs
                       .replace(/[\u{1FA00}-\u{1FA6F}]/gu, '') // Chess Symbols
                       .replace(/[\u{1FA70}-\u{1FAFF}]/gu, '') // Symbols and Pictographs Extended-A
                       .replace(/[\u{2300}-\u{23FF}]/gu, '')   // Miscellaneous Technical
                       .replace(/[\u{FE00}-\u{FE0F}]/gu, '')   // Variation Selectors
                       .replace(/[\u{200D}]/gu, '')            // Zero Width Joiner
                       .trim();
        }

        function speak(text) {
            // Stop any ongoing speech
            window.speechSynthesis.cancel();

            // Remove emoji from text (keep only the word)
            const cleanText = removeAllEmojis(text);

            if (!cleanText) return;

            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 0.9; // Slightly slower for clarity
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Use selected voice if available
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        function speakAll() {
            // Stop any ongoing speech
            window.speechSynthesis.cancel();

            // Get all words from workspace in order
            const workspace = document.getElementById('workspace');
            const canvasTerms = Array.from(workspace.querySelectorAll('.canvas-term'))
                .map(el => el.textContent.replace('√ó', '').trim());

            if (canvasTerms.length === 0) {
                alert('No words in workspace to speak!');
                return;
            }

            // Remove emojis from each term and join with spaces
            const cleanTerms = canvasTerms.map(term => removeAllEmojis(term)).filter(term => term);

            const fullText = cleanTerms.join(' ');

            const utterance = new SpeechSynthesisUtterance(fullText);
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Use selected voice if available
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        // Voice modal handlers
        document.addEventListener('DOMContentLoaded', () => {
            const voiceModal = document.getElementById('voiceModal');
            const closeVoiceModalBtn = document.getElementById('closeVoiceModalBtn');

            closeVoiceModalBtn.addEventListener('click', () => {
                voiceModal.style.display = 'none';
            });

            // Close on background click
            voiceModal.addEventListener('click', (e) => {
                if (e.target === voiceModal) {
                    voiceModal.style.display = 'none';
                }
            });
        });

        // Setup Modal (API Key + Voice) Management
        let apiKey = localStorage.getItem('openai_api_key') || sessionStorage.getItem('openai_api_key') || '';
        const setupModal = document.getElementById('setupModal');
        const saveSetupBtn = document.getElementById('saveSetupBtn');
        const testVoiceBtn = document.getElementById('testVoiceBtn');
        const changeVoiceBtn = document.getElementById('changeVoiceBtn');
        const voiceSelectModal = document.getElementById('voiceSelectModal');

        // Check if server has API key configured
        let hasServerKey = false;
        fetch(buildUrl('/api/check-server-key'))
            .then(res => res.json())
            .then(data => {
                hasServerKey = data.hasServerKey;

                // Hide setup modal if voice is already set
                const hasVoice = localStorage.getItem('tts_voice');
                if (hasVoice) {
                    setupModal.style.display = 'none';
                }
            })
            .catch(err => {
                console.error('Failed to check server key:', err);
                // Fallback: hide modal if voice is set
                const hasVoice = localStorage.getItem('tts_voice');
                if (hasVoice) {
                    setupModal.style.display = 'none';
                }
            });

        // Test voice button
        testVoiceBtn.addEventListener('click', () => {
            const voiceName = voiceSelectModal.value;
            if (voiceName) {
                const testVoice = availableVoices.find(v => v.name === voiceName);
                const utterance = new SpeechSynthesisUtterance('Hello! This is how I sound.');
                utterance.voice = testVoice;
                utterance.rate = 0.9;
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            } else {
                const utterance = new SpeechSynthesisUtterance('Hello! This is the default voice.');
                utterance.rate = 0.9;
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            }
        });

        saveSetupBtn.addEventListener('click', () => {
            const voiceSelectModal = document.getElementById('voiceSelectModal');
            const voiceName = voiceSelectModal ? voiceSelectModal.value : '';
            if (!voiceName) {
                alert('Please select a voice for text-to-speech');
                return;
            }

            // Store voice selection
            selectedVoice = availableVoices.find(v => v.name === voiceName);
            localStorage.setItem('tts_voice', voiceName);

            setupModal.style.display = 'none';
        });

        changeVoiceBtn.addEventListener('click', () => {
            setupModal.style.display = 'flex';
        });

        // Main app logic
        let allTerms = [];
        let canvasTerms = [];
        let suggestionsDebounceTimer = null;
        let lastSuggestedWords = '';

        // Category data with emojis and words
        const categories = {
            'ü§ñ Context': { emoji: 'ü§ñ', name: 'Context', words: [] },
            'üë§ Pronouns': { emoji: 'üë§', name: 'Pronouns', words: ['üë§ I', 'üë• you', 'üë® he', 'üë© she', '‚ö° it', 'üë´ we', 'üë• they', 'üôã me', 'üôã‚Äç‚ôÇÔ∏è him', 'üôã‚Äç‚ôÄÔ∏è her', 'ü§ù us', 'üë¨ them', 'üìå my', 'üìç your', 'üîπ his', 'üî∏ her', '‚≠ê its', 'üåü our', '‚ú® their', 'üëâ this', 'üëà that', 'üîΩ these', 'üîº those', '‚ùì who', '‚ùî what', 'üîÄ which', 'üè∑Ô∏è whose'] },
            '‚ùì Question Words': { emoji: '‚ùì', name: 'Question Words', words: ['‚ùì who', '‚ùî what', '‚è∞ when', 'üìç where', 'ü§î why', 'üõ†Ô∏è how', 'üîÄ which', 'üè∑Ô∏è whose', 'üí∞ how much', 'üî¢ how many', '‚è±Ô∏è how long', 'üìè how far', 'üîÅ how often'] },
            'üìç Prepositions': { emoji: 'üìç', name: 'Prepositions', words: ['üì• in', 'üîõ on', 'üìç at', 'üëâ by', 'ü§ù with', '‚¨ÖÔ∏è from', '‚û°Ô∏è to', 'üì¶ of', 'üéÅ for', 'üí≠ about', '‚¨ÜÔ∏è above', '‚ñ∂Ô∏è after', 'üö´ against', 'üõ§Ô∏è along', 'üé™ among', 'üîÑ around', '‚è™ before', '‚¨áÔ∏è behind', 'üîΩ below', '‚¨å between', 'üåå beyond', '‚¨áÔ∏è down', '‚è≥ during', 'üö∑ except', 'üè† inside', 'üì• into', 'üíù like', 'üìå near', 'üîå off', 'üö™ out', 'üèûÔ∏è outside', 'üîù over', '‚èÆÔ∏è past', 'üìÖ since', 'üîÄ through', 'üéØ toward', '‚¨áÔ∏è under', '‚è≥ until', '‚¨ÜÔ∏è up', 'üì¶ within', 'üö´ without'] },
            'üôè Politeness': { emoji: 'üôè', name: 'Politeness', words: ['üôè please', 'üíù thank you', 'üôå thanks', 'üòî sorry', 'üôã excuse me', 'ü§ó welcome'] },
            'üëã Greetings': { emoji: 'üëã', name: 'Greetings', words: ['üëã hello', '‚úã hi', 'üôå hey', 'üåÖ good morning', '‚òÄÔ∏è good afternoon', 'üåÜ good evening', 'üåô good night', 'üëã goodbye', '‚úåÔ∏è bye', 'üëÄ see you', 'üíù take care', 'ü§ù nice to meet you', '‚ùì how are you'] },
            'üó∫Ô∏è Location': { emoji: 'üó∫Ô∏è', name: 'Location', words: ['üìç here', 'üëâ there', 'üåç everywhere', '‚ùì somewhere', 'üó∫Ô∏è anywhere', 'üö´ nowhere', '‚¨ÜÔ∏è up', '‚¨áÔ∏è down', '‚¨ÖÔ∏è left', '‚û°Ô∏è right', '‚ñ∂Ô∏è forward', '‚óÄÔ∏è backward', 'üîú ahead', 'üîô behind', 'üìå nearby', 'üåå far', 'ü§è close', '‚ÜóÔ∏è away', 'üîÑ around', 'üè† inside', 'üå≥ outside', '‚¨ÜÔ∏è upstairs', '‚¨áÔ∏è downstairs', '‚ÜîÔ∏è next to'] },
            '‚è∞ Time': { emoji: '‚è∞', name: 'Time', words: ['‚ö° now', '‚è∞ then', 'üìÖ today', '‚èÆÔ∏è yesterday', '‚è≠Ô∏è tomorrow', 'üåô tonight', 'üåÖ morning', '‚òÄÔ∏è afternoon', 'üåÜ evening', 'üåÉ night', '‚è∞ later', 'üîú soon', '‚è∞ early', '‚åõ late', '‚è™ before', '‚è© after', '‚è≥ during', '‚åö while', '‚ôæÔ∏è always', 'üö´ never', 'üîÑ sometimes', 'üìä often', 'ü•â rarely', 'üìà usually', '‚úÖ already', '‚è∞ yet', '‚è∏Ô∏è still', '‚ö° just'] },
            'üëÅÔ∏è Senses': { emoji: 'üëÅÔ∏è', name: 'Senses', words: ['üëÅÔ∏è see', 'üëÄ look', 'üì∫ watch', 'üëÇ hear', 'üéß listen', 'üëÉ smell', 'üëÖ taste', 'ü§ö touch', 'üí≠ feel'] },
            'üß† Thinking & Feeling': { emoji: 'üß†', name: 'Thinking & Feeling', words: ['üß† know', 'üí≠ think', '‚ú® believe', 'üí° understand', 'üß† remember', 'üå´Ô∏è forget', 'üìö learn', 'üåà imagine', 'üíù want', 'üìç need', '‚ù§Ô∏è like', 'üíñ love', 'üíî hate', 'üíù care', '‚ö° do', 'üî® make', 'üì¶ get', 'ü§≤ take', 'üéÅ give', 'üìå put', 'üîß use', 'üîç find', 'üëâ show', 'ü§ù help', '‚úÖ let', 'üì¶ keep', 'üëã leave', '‚ñ∂Ô∏è start', '‚èπÔ∏è stop', 'üèÅ end', '‚ñ∂Ô∏è continue', 'üí™ try', '‚ùå fail', 'üíº work', 'üéÆ play', 'üò¥ rest', '‚è∞ wait', 'üìç stay', 'üîÑ become', 'üîÄ change', 'üå± grow', '‚ûï add', '‚ûñ remove', 'üìâ lose', 'üèÜ win', 'üõí buy', 'üíµ sell', 'üí∏ spend', 'üí∞ save', 'ü§ù share'] },
            'üö∂ Doing & Talking': { emoji: 'üö∂', name: 'Doing & Talking', words: ['üö∂ go', 'üëã come', 'üèÉ move', 'üö∂ walk', 'üèÉ run', 'ü¶ò jump', 'üßó climb', '‚¨áÔ∏è fall', 'ü™ë sit', 'üßç stand', 'üò¥ sleep', '‚è∞ wake', 'üîÑ turn', 'üëâ push', 'ü§≤ pull', '‚¨ÜÔ∏è lift', 'üì¶ carry', 'ü§≤ hold', '‚úä grab', 'ü§æ catch', 'üéØ throw', 'üëä hit', 'ü¶µ kick', 'ü§ö touch', 'ü§≤ reach', 'üëâ point', 'üëã wave', 'üö™ open', 'üîí close', 'üí• break', 'üîß fix', 'üèóÔ∏è build', '‚ú® clean', 'üöø wash', 'üí® dry', 'üëï wear', '‚ûñ remove', '‚¨áÔ∏è drop', 'üí¨ say', 'üó£Ô∏è tell', 'üí¨ talk', '‚ùì ask', 'üí° answer', '‚Ü©Ô∏è reply', 'üìñ explain', 'üìù describe', 'üìû call', 'üì£ shout', 'ü§´ whisper', 'üò± yell', 'üòÇ laugh', 'üòä smile', 'üçΩÔ∏è eat', 'ü•§ drink'] },
            'üî¢ Quantity': { emoji: 'üî¢', name: 'Quantity', words: ['üíØ all', 'üìä some', 'üìà many', 'ü§è few', 'üíØ much', 'ü§è little', '‚ûï more', '‚ûñ less', 'üèÜ most', 'ü•â least', '‚úÖ enough', 'üö´ none', '‚ùì any', '1Ô∏è‚É£ each', 'üíØ every', '2Ô∏è‚É£ both', 'üîÄ either', 'üö´ neither', '¬Ω half', 'üíØ whole', 'üß© part', 'üß© piece'] },
            '‚ú® Describing Words': { emoji: '‚ú®', name: 'Describing Words', words: ['üëç good', 'üëé bad', 'üìè big', 'ü§è small', 'üìè long', 'üìê short', 'üóº tall', '‚¨ÜÔ∏è high', '‚¨áÔ∏è low', '‚ÜîÔ∏è wide', 'üö™ narrow', 'üìö thick', 'üìÑ thin', '‚öñÔ∏è heavy', 'ü™∂ light', 'ü™® hard', 'üß∏ soft', 'üî• hot', '‚ùÑÔ∏è cold', '‚òÄÔ∏è warm', 'üßä cool', '‚ú® new', 'üìú old', 'üë∂ young', '‚ö° fast', 'üêå slow', '‚úÖ easy', 'üò∞ difficult', '‚ú® clean', 'üóëÔ∏è dirty', 'üòä nice', 'üí™ strong', 'üòî weak', 'üí° bright', 'üåë dark', 'üì¢ loud', 'ü§´ quiet', 'üì¶ full', 'üì≠ empty', '‚úÖ safe', '‚ö†Ô∏è dangerous'] },
            'üîó Connectors': { emoji: 'üîó', name: 'Connectors', words: ['‚ûï and', 'üîÄ or', '‚ùó but', '‚ÜóÔ∏è so', 'üí° because', '‚ùì if', '‚û°Ô∏è then', '‚è∞ while', 'üö´ unless', '‚è≥ until', 'üìÖ since'] },
            '‚úÖ Yes & No': { emoji: '‚úÖ', name: 'Yes & No', words: ['‚úÖ yes', '‚ùå no', 'üëå okay', 'üëç sure', 'üòä fine', '‚úÖ right', 'ü§î maybe', '‚úÖ I agree', '‚ùå I disagree', 'ü§î I think so', "ü§∑ I don't think so"] },
            'üì¶ Common Nouns': { emoji: 'üì¶', name: 'Common Nouns', words: ['üë§ person', 'üë• people', 'üë® man', 'üë© woman', 'üë∂ child', 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ family', 'ü§ù friend', 'üì¶ thing', 'üìç place', '‚è∞ time', 'üìÖ day', 'üìÜ year', 'üõ§Ô∏è way', 'üíº work', 'üè† home', 'üè° house', 'üö™ room', 'üö™ door', 'ü™ü window', 'ü™ë table', 'ü™ë chair', 'üõèÔ∏è bed', 'üçΩÔ∏è food', 'üíß water', 'üí∞ money', 'üìö book', 'üì± phone', 'üöó car', 'üèôÔ∏è city', 'üåç country', 'üåé world', 'üí´ life', '‚úã hand', 'üëÅÔ∏è eye', 'üòä face', 'üß† head', 'ü´Ä body', 'üß© part', '‚ÜîÔ∏è side', '‚¨ÖÔ∏è back', '‚¨ÜÔ∏è top', '‚¨áÔ∏è bottom', 'üèÅ end', 'üìç point', 'üí¨ word', 'üè∑Ô∏è name', 'üî¢ number', '‚ùì question', '‚ö†Ô∏è problem', 'üí° idea', 'üìñ story'] }
        };

        const wordBank = document.getElementById('wordBank');
        const workspace = document.getElementById('workspace');
        const loading = document.getElementById('loading');
        const searchInput = document.getElementById('searchInput');
        const termCount = document.getElementById('termCount');
        const imageInput = document.getElementById('imageInput');
        const attachImageBtn = document.getElementById('attachImageBtn');
        const speakAllBtn = document.getElementById('speakAllBtn');
        const progressChecklist = document.getElementById('progressChecklist');

        // Progress tracker
        function showProgressChecklist() {
            progressChecklist.style.display = 'block';
            resetProgressChecklist();
            simulateProgress();
        }

        function hideProgressChecklist() {
            progressChecklist.style.display = 'none';
        }

        function resetProgressChecklist() {
            const items = progressChecklist.querySelectorAll('.progress-item');
            items.forEach(item => {
                item.classList.remove('completed', 'in-progress');
                item.querySelector('.progress-icon').textContent = '‚è≥';
            });
        }

        function updateProgress(stage) {
            const item = progressChecklist.querySelector(`[data-stage="${stage}"]`);
            if (!item) return;

            // Mark previous stages as completed
            for (let i = 1; i < stage; i++) {
                const prevItem = progressChecklist.querySelector(`[data-stage="${i}"]`);
                if (prevItem && !prevItem.classList.contains('completed')) {
                    prevItem.classList.remove('in-progress');
                    prevItem.classList.add('completed');
                    prevItem.querySelector('.progress-icon').textContent = '‚úÖ';
                }
            }

            // Mark current stage as in-progress
            item.classList.add('in-progress');
            item.querySelector('.progress-icon').textContent = '‚öôÔ∏è';
        }

        function completeAllProgress() {
            const items = progressChecklist.querySelectorAll('.progress-item');
            items.forEach(item => {
                item.classList.remove('in-progress');
                item.classList.add('completed');
                item.querySelector('.progress-icon').textContent = '‚úÖ';
            });
        }

        // Simulate progress through stages (approximate timings)
        let progressInterval;
        function simulateProgress() {
            clearInterval(progressInterval);
            let currentStage = 1;
            const stageDurations = [5000, 8000, 12000, 5000, 15000, 8000, 5000, 5000, 8000, 7000]; // milliseconds per stage

            updateProgress(1);
            let elapsed = 0;

            progressInterval = setInterval(() => {
                elapsed += 1000;

                // Check if we should move to next stage
                let totalTime = 0;
                for (let i = 0; i < currentStage; i++) {
                    totalTime += stageDurations[i];
                }

                if (elapsed >= totalTime && currentStage < 10) {
                    currentStage++;
                    updateProgress(currentStage);
                }
            }, 1000);
        }

        // Initialize with default categories
        displayWordBank();

        // Speak All button handler
        speakAllBtn.addEventListener('click', speakAll);

        // Image upload handling
        attachImageBtn.addEventListener('click', () => {
            imageInput.click();
        });

        imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            console.log('\n' + '='.repeat(80));
            console.log('üì∑ IMAGE UPLOAD STARTED');
            console.log('='.repeat(80));
            console.log('üìÅ File:', file.name);
            console.log('üì¶ Size:', (file.size / 1024).toFixed(1), 'KB');
            console.log('üìÑ Type:', file.type);
            console.log('‚è∞ Started at:', new Date().toLocaleTimeString());

            if (!hasServerKey && !apiKey) {
                console.error('‚ùå No API key available');
                alert('Please enter your API key first');
                setupModal.style.display = 'flex';
                imageInput.value = '';
                return;
            }

            loading.classList.add('show');
            document.querySelector('.loading-text').textContent = 'Analyzing image to generate contextually relevant vocab. This currently takes about 20-30 seconds.';
            showProgressChecklist();
            attachImageBtn.disabled = true;

            try {
                console.log('\nüì§ STEP 1: Analyzing image with vision API...');
                const formData = new FormData();
                formData.append('image', file);
                formData.append('api_key', apiKey);

                const response = await fetch(buildUrl('/analyze-image'), {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    console.error('‚ùå Image analysis failed:', response.status, response.statusText);
                    const errorText = await response.text();
                    let errorMessage = 'Failed to analyze image';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                        console.error('‚ùå Error from server:', errorData);
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                        console.error('‚ùå Raw error:', errorText);
                    }
                    throw new Error(errorMessage);
                }

                console.log('‚úÖ Image analysis response received');
                const data = await response.json();

                if (data.success) {
                    console.log('‚úÖ Image analyzed successfully!');
                    console.log('üìù Description:', data.description);
                    console.log('\nüì§ STEP 2: Generating vocabulary from description...');

                    // Use the description as context to generate terms
                    await generateTermsFromContext(data.description);

                    console.log('‚úÖ IMAGE UPLOAD COMPLETE');
                    console.log('‚è∞ Completed at:', new Date().toLocaleTimeString());
                    console.log('='.repeat(80) + '\n');
                } else {
                    console.error('‚ùå Image analysis returned success: false', data);
                    alert('Error analyzing image: ' + data.error);
                }
            } catch (error) {
                console.error('‚ùå IMAGE UPLOAD FAILED:', error);
                console.error('Stack trace:', error.stack);
                alert('Error analyzing image: ' + error.message);
            } finally {
                clearInterval(progressInterval);
                completeAllProgress();
                setTimeout(() => {
                    loading.classList.remove('show');
                    hideProgressChecklist();
                    document.querySelector('.loading-text').textContent = 'Generating words...';
                }, 800); // Show completed state briefly
                attachImageBtn.disabled = false;
                imageInput.value = ''; // Reset file input
            }
        });

        async function generateTermsFromContext(context) {
            if (!context) {
                console.error('‚ùå No context available');
                alert('No context available');
                return;
            }

            if (!hasServerKey && !apiKey) {
                console.error('‚ùå No API key provided');
                alert('Please enter your API key first');
                setupModal.style.display = 'flex';
                return;
            }

            console.log('\n' + '='.repeat(80));
            console.log('üöÄ STARTING VOCAB GENERATION FROM CONTEXT');
            console.log('='.repeat(80));
            console.log('üìù Context:', context.substring(0, 100) + (context.length > 100 ? '...' : ''));
            console.log('‚è∞ Started at:', new Date().toLocaleTimeString());

            loading.classList.add('show');

            try {
                console.log('\nüì§ Sending /generate request...');
                const response = await fetch(buildUrl('/generate'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ context, api_key: apiKey })
                });

                if (!response.ok) {
                    console.error('‚ùå Response not OK:', response.status, response.statusText);
                    const errorText = await response.text();
                    let errorMessage = 'Failed to generate vocabulary';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                        console.error('‚ùå Error from server:', errorData);
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                        console.error('‚ùå Raw error:', errorText);
                    }
                    throw new Error(errorMessage);
                }

                console.log('‚úÖ Response received, parsing JSON...');
                const data = await response.json();

                if (data.success) {
                    console.log('‚úÖ Success! Received', data.terms.length, 'terms');
                    console.log('üìä Sample terms:', data.terms.slice(0, 5));

                    // Put generated terms in the Context category
                    categories['ü§ñ Context'].words = data.terms;
                    allTerms = getAllTerms();
                    displayWordBank();

                    console.log('‚úÖ Terms added to word bank');
                    console.log('‚è∞ Completed at:', new Date().toLocaleTimeString());
                    console.log('='.repeat(80) + '\n');
                } else {
                    console.error('‚ùå Server returned success: false', data);
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('‚ùå GENERATION FAILED:', error);
                console.error('Stack trace:', error.stack);
                alert('Error generating terms: ' + error.message);
            } finally {
                loading.classList.remove('show');
            }
        }

        function getAllTerms() {
            let terms = [];
            for (let categoryKey in categories) {
                terms = terms.concat(categories[categoryKey].words);
            }
            return terms;
        }

        function displayWordBank(searchQuery = '') {
            wordBank.innerHTML = '';

            for (let categoryKey in categories) {
                const categoryData = categories[categoryKey];
                const categoryTerms = categoryData.words;

                // Filter by search if applicable
                let filteredTerms = categoryTerms;
                if (searchQuery) {
                    filteredTerms = categoryTerms.filter(term =>
                        term.toLowerCase().includes(searchQuery.toLowerCase())
                    );
                }

                // Skip empty categories when searching
                if (searchQuery && filteredTerms.length === 0) continue;

                // Create category
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';

                // Category header
                const header = document.createElement('div');
                header.className = 'category-header';
                header.innerHTML = `
                    <span class="category-icon">${categoryData.emoji}</span>
                    <span class="category-name">${categoryData.name} (${filteredTerms.length})</span>
                    <span class="category-arrow">‚ñ∂</span>
                `;

                // Category content
                const content = document.createElement('div');
                content.className = 'category-content';

                // Add terms
                filteredTerms.forEach(term => {
                    const card = document.createElement('div');
                    card.className = 'bank-term';
                    card.textContent = term;
                    card.draggable = true;

                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', term);
                        e.dataTransfer.effectAllowed = 'copy';
                    });

                    card.addEventListener('click', (e) => {
                        // On touch devices, only add on tap if not dragging
                        if (isTouchDevice && touchDragState.ghost) {
                            return; // This was a drag, not a tap
                        }
                        addToCanvas(term);
                    });

                    // Add touch event handlers for drag on touch devices
                    if (isTouchDevice) {
                        card.addEventListener('touchstart', (e) => {
                            handleTouchStart(e, card, term, 'bank');
                        }, { passive: true });
                    }

                    content.appendChild(card);
                });

                // Toggle expand/collapse
                header.addEventListener('click', () => {
                    const arrow = header.querySelector('.category-arrow');
                    const isExpanded = content.classList.contains('expanded');

                    if (isExpanded) {
                        content.classList.remove('expanded');
                        arrow.classList.remove('expanded');
                        header.classList.remove('expanded');
                    } else {
                        content.classList.add('expanded');
                        arrow.classList.add('expanded');
                        header.classList.add('expanded');
                    }
                });

                categoryDiv.appendChild(header);
                categoryDiv.appendChild(content);
                wordBank.appendChild(categoryDiv);
            }

            updateTermCount();
        }

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value;
            displayWordBank(query);
        });

        // Touch drag and drop system
        let touchDragState = {
            active: false,
            element: null,
            term: null,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            ghost: null,
            sourceType: null, // 'bank', 'canvas', 'suggestion'
            isReordering: false,
            hasExceededThreshold: false
        };

        function createTouchGhost(element, x, y) {
            const ghost = element.cloneNode(true);
            ghost.style.position = 'fixed';
            ghost.style.left = x + 'px';
            ghost.style.top = y + 'px';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '10000';
            ghost.style.opacity = '0.8';
            ghost.style.transform = 'scale(1.05) rotate(3deg)';
            ghost.style.transition = 'none';
            ghost.classList.add('dragging-ghost');

            // Remove remove button from ghost
            const removeBtn = ghost.querySelector('.remove-btn');
            if (removeBtn) removeBtn.remove();

            document.body.appendChild(ghost);
            return ghost;
        }

        function updateTouchGhostPosition(x, y) {
            if (touchDragState.ghost) {
                touchDragState.ghost.style.left = x + 'px';
                touchDragState.ghost.style.top = y + 'px';
            }
        }

        function removeTouchGhost() {
            if (touchDragState.ghost) {
                touchDragState.ghost.remove();
                touchDragState.ghost = null;
            }
        }

        function handleTouchStart(e, element, term, sourceType) {
            // Prevent if already dragging
            if (touchDragState.active) return;

            // Don't start drag if tapping remove button
            if (e.target.classList.contains('remove-btn')) return;

            const touch = e.touches[0];

            touchDragState.active = true;
            touchDragState.element = element;
            touchDragState.term = term;
            touchDragState.startX = touch.clientX;
            touchDragState.startY = touch.clientY;
            touchDragState.currentX = touch.clientX;
            touchDragState.currentY = touch.clientY;
            touchDragState.sourceType = sourceType;
            touchDragState.isReordering = (sourceType === 'canvas');
            touchDragState.hasExceededThreshold = false;

            // Add touching class for visual feedback
            element.classList.add('touching');
            document.body.classList.add('touching');

            // Vibrate on supported devices
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function handleTouchMove(e) {
            if (!touchDragState.active) return;

            const touch = e.touches[0];
            touchDragState.currentX = touch.clientX;
            touchDragState.currentY = touch.clientY;

            // Calculate distance moved
            const deltaX = Math.abs(touch.clientX - touchDragState.startX);
            const deltaY = Math.abs(touch.clientY - touchDragState.startY);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (!touchDragState.hasExceededThreshold && distance > TOUCH_DRAG_THRESHOLD) {
                touchDragState.hasExceededThreshold = true;
            }

            // Allow natural scrolling until we are sure this is a drag
            if (!touchDragState.hasExceededThreshold) {
                return;
            }

            e.preventDefault(); // Prevent scrolling once dragging begins

            const rect = touchDragState.element.getBoundingClientRect();

            // Create ghost element on first real drag movement
            if (!touchDragState.ghost) {
                touchDragState.ghost = createTouchGhost(
                    touchDragState.element,
                    touch.clientX - rect.width / 2,
                    touch.clientY - rect.height / 2
                );
                workspace.classList.add('dragover');
            }

            updateTouchGhostPosition(
                touch.clientX - rect.width / 2,
                touch.clientY - rect.height / 2
            );

            if (touchDragState.isReordering) {
                const afterElement = getDragAfterElement(workspace, touch.clientX, touch.clientY);
                if (afterElement == null) {
                    workspace.appendChild(touchDragState.element);
                } else {
                    workspace.insertBefore(touchDragState.element, afterElement);
                }
            } else {
                // Show insertion marker for new items
                if (!insertionMarker) {
                    insertionMarker = document.createElement('div');
                    insertionMarker.className = 'insertion-marker';
                }

                const afterElement = getDragAfterElement(workspace, touch.clientX, touch.clientY);
                if (afterElement == null) {
                    workspace.appendChild(insertionMarker);
                } else {
                    workspace.insertBefore(insertionMarker, afterElement);
                }
            }
        }

        function handleTouchEnd(e) {
            if (!touchDragState.active) return;

            // Remove touching class
            if (touchDragState.element) {
                touchDragState.element.classList.remove('touching');
            }
            document.body.classList.remove('touching');

            workspace.classList.remove('dragover');

            // If we have a ghost, this was a drag operation
            if (touchDragState.ghost) {
                e.preventDefault();

                const touch = e.changedTouches[0];
                const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);

                // Check if dropped on workspace
                if (workspace.contains(dropTarget) || dropTarget === workspace) {
                    if (!touchDragState.isReordering) {
                        // Adding new term from bank or suggestions
                        const afterElement = getDragAfterElement(workspace, touch.clientX, touch.clientY);
                        addToCanvas(touchDragState.term, afterElement);

                        // Vibrate on success
                        if (navigator.vibrate) {
                            navigator.vibrate(20);
                        }
                    } else {
                        // Reordering - already done in touchmove
                        if (navigator.vibrate) {
                            navigator.vibrate(10);
                        }
                    }
                }

                // Clean up insertion marker
                if (insertionMarker) {
                    insertionMarker.remove();
                    insertionMarker = null;
                }
            }

            // Clean up
            removeTouchGhost();
            touchDragState.active = false;
            touchDragState.element = null;
            touchDragState.term = null;
            touchDragState.ghost = null;
            touchDragState.isReordering = false;
            touchDragState.hasExceededThreshold = false;
        }

        function handleTouchCancel(e) {
            // Clean up on cancel
            if (touchDragState.element) {
                touchDragState.element.classList.remove('touching');
            }
            document.body.classList.remove('touching');
            workspace.classList.remove('dragover');
            removeTouchGhost();
            if (insertionMarker) {
                insertionMarker.remove();
                insertionMarker = null;
            }
            touchDragState.active = false;
            touchDragState.element = null;
            touchDragState.term = null;
            touchDragState.ghost = null;
            touchDragState.isReordering = false;
            touchDragState.hasExceededThreshold = false;
        }

        // Add global touch event listeners
        if (isTouchDevice) {
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchcancel', handleTouchCancel, { passive: false });
        }

        // Canvas drag and drop
        let draggedCard = null;
        let insertionMarker = null;

        workspace.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = draggedCard ? 'move' : 'copy';
            workspace.classList.add('dragover');

            const afterElement = getDragAfterElement(workspace, e.clientX, e.clientY);

            // Remove existing marker
            if (insertionMarker && !draggedCard) {
                insertionMarker.remove();
                insertionMarker = null;
            }

            if (draggedCard) {
                // Reordering existing card
                if (afterElement == null) {
                    workspace.appendChild(draggedCard);
                } else {
                    workspace.insertBefore(draggedCard, afterElement);
                }
            } else {
                // Show insertion marker for new items
                if (!insertionMarker) {
                    insertionMarker = document.createElement('div');
                    insertionMarker.className = 'insertion-marker';
                }

                if (afterElement == null) {
                    workspace.appendChild(insertionMarker);
                } else {
                    workspace.insertBefore(insertionMarker, afterElement);
                }
            }
        });

        workspace.addEventListener('dragleave', (e) => {
            if (e.target === workspace) {
                workspace.classList.remove('dragover');
                if (insertionMarker) {
                    insertionMarker.remove();
                    insertionMarker = null;
                }
            }
        });

        workspace.addEventListener('drop', (e) => {
            e.preventDefault();
            workspace.classList.remove('dragover');

            // Clean up insertion marker
            if (insertionMarker) {
                insertionMarker.remove();
                insertionMarker = null;
            }

            const term = e.dataTransfer.getData('text/plain');
            if (term && !draggedCard) {
                // Adding from sidebar
                const afterElement = getDragAfterElement(workspace, e.clientX, e.clientY);
                addToCanvas(term, afterElement);
            }

            draggedCard = null;
        });

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.canvas-term:not(.dragging)')];

            let closestElement = null;
            let closestDistance = Infinity;

            draggableElements.forEach(child => {
                const box = child.getBoundingClientRect();
                const centerX = box.left + box.width / 2;
                const centerY = box.top + box.height / 2;

                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

                // If cursor is to the left of the element's center, insert before it
                if (x < centerX && distance < closestDistance) {
                    closestDistance = distance;
                    closestElement = child;
                }
            });

            return closestElement;
        }

        function addToCanvas(term, beforeElement) {
            const card = document.createElement('div');
            card.className = 'canvas-term';
            card.textContent = term;
            card.draggable = true;

            // Click to speak
            card.addEventListener('click', (e) => {
                // Don't speak when clicking remove button
                if (e.target.classList.contains('remove-btn')) return;
                // On touch devices, only speak if not dragging
                if (isTouchDevice && touchDragState.ghost) {
                    return; // This was a drag, not a tap
                }
                speak(term);
            });

            // Remove button
            const removeBtn = document.createElement('div');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '√ó';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                card.remove();
                canvasTerms = canvasTerms.filter(t => t.element !== card);

                // Show empty state if no more terms
                const emptyState = workspace.querySelector('.empty-state');
                if (emptyState && canvasTerms.length === 0) {
                    emptyState.style.display = 'block';
                }

                // Update suggestions after removal
                debouncedFetchSuggestions();
            });
            card.appendChild(removeBtn);

            // Drag events for reordering
            card.addEventListener('dragstart', (e) => {
                draggedCard = card;
                card.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
                draggedCard = null;
            });

            // Add touch event handlers for drag on touch devices
            if (isTouchDevice) {
                card.addEventListener('touchstart', (e) => {
                    handleTouchStart(e, card, term, 'canvas');
                }, { passive: true });
            }

            // Insert at position or append
            if (beforeElement) {
                workspace.insertBefore(card, beforeElement);
            } else {
                workspace.appendChild(card);
            }

            canvasTerms.push({ term, element: card });

            // Hide empty state
            const emptyState = workspace.querySelector('.empty-state');
            if (emptyState && canvasTerms.length > 0) {
                emptyState.style.display = 'none';
            }

            // Update suggestions after adding
            debouncedFetchSuggestions();
        }

        function updateTermCount() {
            const total = getAllTerms().length;
            termCount.textContent = `${total} words in bank`;
        }

        // Suggestions functionality
        async function fetchSuggestions() {
            const suggestionsList = document.getElementById('suggestionsList');

            // Get current workspace words
            const wordsInWorkspace = Array.from(workspace.querySelectorAll('.canvas-term'))
                .map(el => el.textContent.replace('√ó', '').trim())
                .map(term => term.replace(/[\u{1F300}-\u{1F9FF}]/gu, '').trim())
                .filter(term => term);

            // Create a key for caching
            const wordsKey = wordsInWorkspace.join(' ');

            // Don't refetch if same words
            if (wordsKey === lastSuggestedWords) {
                return;
            }
            lastSuggestedWords = wordsKey;

            // Show loading state
            suggestionsList.innerHTML = '<div class="suggestions-loading">Loading suggestions...</div>';

            try {
                const response = await fetch(buildUrl('/suggest-next-words'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        words: wordsInWorkspace,
                        api_key: apiKey
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch suggestions');
                }

                const data = await response.json();

                if (data.success && data.suggestions) {
                    displaySuggestions(data.suggestions);
                } else {
                    suggestionsList.innerHTML = '<div class="suggestions-empty">No suggestions available</div>';
                }
            } catch (error) {
                console.error('Error fetching suggestions:', error);
                suggestionsList.innerHTML = '<div class="suggestions-empty">Error loading suggestions</div>';
            }
        }

        function displaySuggestions(suggestions) {
            const suggestionsList = document.getElementById('suggestionsList');
            suggestionsList.innerHTML = '';

            suggestions.forEach(word => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = word;
                item.draggable = true;

                // Click to add to workspace
                item.addEventListener('click', () => {
                    // On touch devices, only add on tap if not dragging
                    if (isTouchDevice && touchDragState.ghost) {
                        return; // This was a drag, not a tap
                    }
                    addToCanvas(word);
                    // Update suggestions after adding
                    debouncedFetchSuggestions();
                });

                // Drag events
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', word);
                    item.style.opacity = '0.5';
                });

                item.addEventListener('dragend', (e) => {
                    item.style.opacity = '1';
                });

                // Add touch event handlers for drag on touch devices
                if (isTouchDevice) {
                    item.addEventListener('touchstart', (e) => {
                        handleTouchStart(e, item, word, 'suggestion');
                    }, { passive: true });
                }

                suggestionsList.appendChild(item);
            });
        }

        function debouncedFetchSuggestions() {
            // Clear existing timer
            if (suggestionsDebounceTimer) {
                clearTimeout(suggestionsDebounceTimer);
            }

            // Set new timer for 1 second
            suggestionsDebounceTimer = setTimeout(() => {
                fetchSuggestions();
            }, 1000);
        }

        // Fetch suggestions on page load (empty workspace = core vocab)
        setTimeout(() => {
            if (apiKey) {
                fetchSuggestions();
            }
        }, 1000);

        // Sentence generation
        const generateSentencesBtn = document.getElementById('generateSentencesBtn');
        const sentencesList = document.getElementById('sentencesList');

        generateSentencesBtn.addEventListener('click', async () => {
            // Get words from workspace in order
            const wordsInWorkspace = Array.from(workspace.querySelectorAll('.canvas-term'))
                .map(el => el.textContent.replace('√ó', '').trim());

            if (wordsInWorkspace.length === 0) {
                alert('Add some words to the workspace first!');
                return;
            }

            if (!apiKey && !hasServerKey) {
                alert('Please enter your API key first');
                setupModal.style.display = 'flex';
                return;
            }

            generateSentencesBtn.disabled = true;
            generateSentencesBtn.textContent = 'Generating...';
            sentencesList.innerHTML = '<div class="sentences-empty">Generating sentences...</div>';

            try {
                const response = await fetch(buildUrl('/generate-sentences'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ words: wordsInWorkspace, api_key: apiKey })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = 'Failed to generate sentences';
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                if (data.success && data.sentences) {
                    sentencesList.innerHTML = '';
                    data.sentences.forEach(sentence => {
                        const sentenceItem = document.createElement('div');
                        sentenceItem.className = 'sentence-item';
                        sentenceItem.textContent = sentence;

                        // Click to speak sentence
                        sentenceItem.addEventListener('click', () => {
                            speak(sentence);
                        });

                        sentencesList.appendChild(sentenceItem);
                    });
                } else {
                    sentencesList.innerHTML = '<div class="sentences-empty">Error generating sentences. Please try again.</div>';
                }
            } catch (error) {
                console.error('Error:', error);
                sentencesList.innerHTML = '<div class="sentences-empty">Error generating sentences. Please try again.</div>';
            } finally {
                generateSentencesBtn.disabled = false;
                generateSentencesBtn.textContent = 'Create Sentences';
            }
        });

        // Focus functionality
        const sidebar = document.getElementById('sidebar');
        const sentencesPanel = document.getElementById('sentencesPanel');
        const focusWordsBtn = document.getElementById('focusWordsBtn');
        const focusSentencesBtn = document.getElementById('focusSentencesBtn');

        focusWordsBtn.addEventListener('click', () => {
            const isFocused = sidebar.classList.contains('focused');

            if (isFocused) {
                sidebar.classList.remove('focused');
                focusWordsBtn.classList.remove('active');
                focusWordsBtn.textContent = '‚Üí';
            } else {
                sidebar.classList.add('focused');
                sentencesPanel.classList.remove('focused');
                focusWordsBtn.classList.add('active');
                focusSentencesBtn.classList.remove('active');
                focusWordsBtn.textContent = '‚Üê';
                focusSentencesBtn.textContent = '‚Üí';
            }
        });

        focusSentencesBtn.addEventListener('click', () => {
            const isFocused = sentencesPanel.classList.contains('focused');

            if (isFocused) {
                sentencesPanel.classList.remove('focused');
                focusSentencesBtn.classList.remove('active');
                focusSentencesBtn.textContent = '‚Üê';
            } else {
                sentencesPanel.classList.add('focused');
                sidebar.classList.remove('focused');
                focusSentencesBtn.classList.add('active');
                focusWordsBtn.classList.remove('active');
                focusSentencesBtn.textContent = '‚Üí';
                focusWordsBtn.textContent = '‚Üí';
            }
        });
    </script>
</body>
</html>
